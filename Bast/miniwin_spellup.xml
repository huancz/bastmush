<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- $Id: miniwin_map.xml 917 2010-12-06 02:00:48Z endavis $ -->
<muclient>
<plugin
   name="miniwin_spellup"
   author="Bast"
   id="eeef0c555a44169e0f1d9674"
   language="Lua"
   purpose="spellup plugin with a miniwindow"
   date_written="2008-07-18"
   requires="4.52"
   version="6.0"
   save_state="y"
   >
<description trim="y">
bspell a all         --> cast all possible spellups
*bspell d all         --> remove all spellups

*bspell a blur  "champion's strength:3"    --> add more to the current list
  to add a spell in a certain place add a : then the place number
*bspell d "night vision" "detect magic"   --> remove those from the list

*bspell fast    --> cast all spellups immediately, as fast as you can
*bspell pause   --> stop casting spellups until a resume
*bspell resume  --> resume casting
*bspell refresh --> requery server for current spells on us

spellup other (name) --> try to spellup another player with picked spellups
                          (eg. spellup other johnsmith)

spellup other (name) all --> try to spellup another player with all spellups
                          (eg. spellup other johnsmith)

*bspell block   --> block a spell with another spell
                           (eg. spellup block + 68 121)
*bspell disable --> disable a spell without taking it out of the list

*bspell help    --> this message

Bugs - Hide shows up as a negative spellup

TODO:
create miniwin based on mine
menu for each spell
 - show Help
 - showskill
 - Info
  - SN
  - stuff from slist
  
have tabs for:
 * Summary
   - how many good/bad/requested spells (can click good/bad/requested to go to good/bad/requested tab)
   - spells that are wearing off in less than one minute
   - recoveries
   - spells pending
   - disabled spells
 * Good
 * Bad
 * Requested
 * Other
   - show blocked
 * Combat - list both spells and skills that can be used in combat
 * Spellups - can click spells in this window to add them
    - columns for each - self, other
    - red can't add - (not practiced)
   
NOTES:
events that need to trigger a retry of spellups
* - spell wearoff
* - spell fail
* - spell success
* - stats change
* - position change
* - afk change
* - have slist
* - connect (and have slist)
* - recovery on
* - recovery off
* - resume
 - skillgain (?)
 
Spellup Other -
 put all at end (does all spellups)
 no all then does the ones you have picked from the spellups tab


</description>

</plugin>

<!--  Triggers  -->
<triggers>


</triggers>


<!--  Script  -->

<script>
<![CDATA[
internalrevision = "$Rev: 917 $"

dofile (GetPluginInfo (GetPluginID (), 20) .. "luapath.lua")

require 'var'
require 'pluginhelper'
require "miniwin"
require "tprint"
require "commas"
require "serialize"
require "ldplugin"
require "findfile"
require "verify"

nfile = scan_dir_for_file (GetInfo(60), "telnet_options.lua")

if nfile then
  -- pull in telnet option handling
  dofile (nfile)
else
  print("Could not load telnet_options.lua, please copy it to your plugin directory")
end

stats = nil

-- 317 = absorb, 484 = spirit shield
--askedspells = {{sn=317}, {sn=484}}
-- askedspells = list of tables with {sn, disabled, blocked}
askedspells_xref = nil

spells_xref = {}
-- spells xref, name to sn

spells = {}
--spells['affected'] = {}
recoveries = {}
--recoveries['affected'] = {}

noneed = false

-- things that can block spells
have_slist = false
waiting = false
need_moves = false
need_mana = false
nocast = false

nocast_rooms = {}
current_room = -1

spellwin = Miniwin:new{name="Spells/Skills"}

function PrefixCheck (t, s)
  for name, item in pairs (t) do
    if string.match (name, "^" .. s) then -- prefix match, so "avoid" matches "avoidance"
      return name, item
    end -- if name matches
  end -- checking table
  return nil  -- not found
end -- PrefixCheck

function justWords(str)
  local t = {}
  local function helper(word) table.insert(t, word) return "" end
  if not str:gsub("%w+", helper):find"%S" then return t end
end  

function find_spellsn(item)
  if not item then
    ColourNote ("red", "", "A nil value was passed to find_spellsn")
    return false
  end
  item = trim (item):lower ()
  local sn = tonumber (item)
  local name
  invalid = false
  -- see if numeric spell numbner given
  if sn and not spells['all'] [sn] then
    ColourNote ("red", "", "Spell number '" .. item .. "' does not exist.")
    invalid = true
    sn = nil
  elseif not sn then
    -- look up word
    sn = spells_xref [item]  -- look for exact match first
                             -- (otherwise "bless" might match "bless weapon")
    if not sn then
      _, sn = PrefixCheck (spells_xref, item)
    end -- not found by exact match
    if not sn then
      ColourNote ("red", "", "Spell named '" .. item .. "' does not exist.")
      invalid = true
    end -- name not found
  end -- if
  return sn, invalid
end -- find_spellsn

function isblocked(sn)
  if phelper.askedspells and askedspells_xref[sn] and phelper.askedspells[askedspells_xref[sn]].blockers then
    for blocker, _ in pairs(phelper.askedspells[askedspells_xref[sn]].blockers) do
      if spells['affected'][blocker] then
        return true
      end
    end
  end
  return false
end

function add_blocker(spell, blocker)
  sn, invalid = find_spellsn(spell)
  blksn, invalid = find_spellsn(blocker)
  if sn and blksn and askedspells_xref[sn] and phelper.askedspells[askedspells_xref[sn]] then
    if phelper.askedspells[askedspells_xref[sn]] then
      if not phelper.askedspells[askedspells_xref[sn]].blockers then
        phelper.askedspells[askedspells_xref[sn]].blockers = {}
      end
      phelper.askedspells[askedspells_xref[sn]].blockers[blksn] = 1
      return true
    end
  end
  return false
end -- add_disabled

function remove_blocker(spell, blocker)
  sn, invalid = find_spellsn(spell)
  blksn, invalid = find_spellsn(blocker)
  if sn and blksn and askedspells_xref[sn] and phelper.askedspells[askedspells_xref[sn]] then
    if phelper.askedspells[askedspells_xref[sn]] then
      phelper.askedspells[askedspells_xref[sn]].blockers[blksn] = nil
    end
    return true
  end
  return false
end

function load_spells(stype)
  local res, text = CallPlugin("aaa72f3b5453567e2bba9d50", "get_spells", stype)
  spells[stype] = assert (loadstring ('return ' .. text or ""))()
end

function load_recoveries(rtype)
  local res, text = CallPlugin("aaa72f3b5453567e2bba9d50", "get_recoveries", rtype)
  recoveries[rtype] = assert (loadstring ('return ' .. text or ""))()
end

function load_spells_xrefs()
  local res, text = CallPlugin("aaa72f3b5453567e2bba9d50", "get_spells_xref", rtype)
  spells_xref = assert (loadstring ('return ' .. text or ""))()
end

function cmd_refresh(cmddict)
  SendNoEcho("slist affected noprompt")
end

function make_askedspells_xrefs ()
  phelper:mdebug('making askedspells xref')
  askedspells_xref = {}
  for k, v in pairs (phelper.askedspells) do
    askedspells_xref [v.sn] = k
  end -- for each spell
end -- make_xrefs

function activatespell(sn, fast)
  fast = verify_bool(fast)
  if spells['all'][sn] then
    v = spells['all'][sn]
    if not spells['affected'][sn] then
      local cast = true
      local recov = spells['all'][sn].recovery
      if recov and recoveries['affected'][recov] then
        cast = false
      end
      if v.disabled or isblocked(sn) then
        cast = false
      end  
      if cast then
        if not fast then
          --print("setting waiting to", sn)
          waiting = tonumber(sn)
        end    
        if tonumber(spells['all'][sn].skilltype) == 1 then
          SendNoEcho('cast ' .. tostring(sn))
        else
          words = justWords(spells['all'][sn].name)
          SendNoEcho (words[1])
        end
        return true
      end
    end
  end
  return false
end

function nextspellup (reason)
  --print("called nextspellup", reason, waiting)
  if have_slist and 
     stats ~= nil and 
     not waiting and 
     not need_mana and 
     not need_moves and 
     not noneed and
     not nocast and
     not phelper.pause and
     tonumber(stats.status.state) == 3 then
     
    --print('got to go through table')
    for k,v in ipairs(phelper.askedspells) do
      if activatespell(v.sn) then
        return
      end
    end
    noneed = true
    
  end
end

function cmd_listspells(cmddict)
  phelper:plugin_header("Spells requested (" .. tostring(#phelper.askedspells) .. ")")
  for i,v in ipairs(phelper.askedspells) do
    tstring = ""
    if v.disabled then
      tstring = tstring .. " - (disabled)"
    end
    if v.blockers then
      tstring = tstring .. " - Blocked by:"
      for sn,t in pairs(v.blockers) do
        tstring = tstring .. " " .. spells['all'][sn].name
      end
    end
    ColourNote("white", "", spells['all'][v.sn].name .. tstring)
  end
end

function cmd_pause(cmddict)
  phelper:plugin_header("Spellup Paused")
  --ColourNote(RGBColourToName(var.plugin_colour), "black", "Spellup Paused")
  phelper.pause = true
end

function cmd_resume(cmddict)
  phelper:plugin_header("Spellup Resumed")
  --ColourNote(RGBColourToName(var.plugin_colour), "black", "Spellup Resumed")
  phelper.pause = false
  noneed = false
  nextspellup("resumed")
end

function cmd_ablocker(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()    
    for i,item in ipairs(cmddict) do
      local place = nil
      colonplace, _ = string.find(item, ':')
      if colonplace and colonplace > 0 then
        tlist = utils.split(item, ':')
        sn = tlist[1]
        blck = tlist[2]
        local test = add_blocker(sn, blck)
        if test then
          ColourNote(RGBColourToName(var.plugin_colour), "black", tostring(sn) .. " is now blocked by " .. tostring(blck))
        end
      end
    end
  end
  return true
end

function cmd_dblocker(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()    
    for i,item in ipairs(cmddict) do
      local place = nil
      colonplace, _ = string.find(item, ':')
      if colonplace and colonplace > 0 then
        tlist = utils.split(item, ':')
        sn = tlist[1]
        blck = tlist[2]
        remove_blocker(sn, blck)
      end
    end
  end
  return true
end


function cmd_disable(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()   
    for i,item in ipairs(cmddict) do
      sn, invalid = find_spellsn(item)
      if sn then
        if askedspells_xref[sn] ~= nil then
          phelper.askedspells[askedspells_xref[sn]].disabled = true
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " disabled")
        else
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " not in list")      
        end
      end
    end
  end
end

function cmd_enable(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()   
    local enabled = false
    for i,item in ipairs(cmddict) do
      sn, invalid = find_spellsn(item)
      if sn then
        if askedspells_xref[sn] ~= nil then
          phelper.askedspells[askedspells_xref[sn]].disabled = false
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " enabled")
          enabled = true
        else
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " not in list")      
        end
      end
    end
    if enabled then
      noneed = false
      nextspellup("spells enabled")
    end
  end
end

function cmd_fast(cmddict)
  for i,v in ipairs(phelper.askedspells) do
    activatespell(tonumber(v.sn), true)
  end
end

function cmd_deletespell(cmddict)
  if #cmddict >= 1 then
    removed = false
    phelper:plugin_header()   
    if cmddict[1] == 'all' then
      phelper.askedspells = {}
      make_askedspells_xrefs()
      ColourNote(RGBColourToName(var.plugin_colour), "black", "All spells removed")
    else
      for i,item in ipairs(cmddict) do
        sn, invalid = find_spellsn(item)
        if sn then
          if askedspells_xref[sn] ~= nil then
            table.remove(phelper.askedspells, askedspells_xref[sn])
            ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " removed")
            removed = true
          else
            ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " not in list")      
          end
          if removed then
            make_askedspells_xrefs()
          end
        end
      end
    end
  end
end

function cmd_addspell(cmddict)
  if #cmddict >= 1 then
    local added = false
    phelper:plugin_header()    
    for i,item in ipairs(cmddict) do
      local place = nil
      colonplace, _ = string.find(item, ':')
      if colonplace and colonplace > 0 then
        tlist = utils.split(item, ':')
        item = tlist[1]
        place = tlist[2]
      end
      sn, invalid = find_spellsn(item)  
      if sn then
        name = spells['all'] [sn].name
        if spells ['all'][sn].percent == 0 then
          ColourNote ("red", "", "You have not learnt '" .. name .. "'.")
          invalid = true
        elseif spells ['all'][sn].percent == 1 then
          ColourNote ("red", "", "You have not practiced '" .. name .. "'.")
          invalid = true
        elseif not spells ['spellup'][sn] then
          ColourNote ("red", "", "Spell '" .. name .. "' is not a spellup.")
          invalid = true
        else
          if askedspells_xref[tonumber(sn)] == nil then
            phelper:mdebug('adding ', item, sn, spells['all'][sn].name, invalid, place)                
            local pos = -1
            if place then
              table.insert(phelper.askedspells,place, {sn=tonumber(sn)})
              pos = tostring(place)
            else
              table.insert(phelper.askedspells, {sn=tonumber(sn)})
              pos = tostring(#phelper.askedspells)
            end
            added = true
            ColourNote(RGBColourToName(var.plugin_colour), "black", "Added " .. spells['all'][tonumber(sn)].name .. " in position " .. pos)
          else
            ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " already in list")
          end
        end -- if
      end
      if added then
        noneed = false
        nextspellup("added new spells")
        make_askedspells_xrefs()
      end
    end -- if number orname found
  end
end

function formatspells()
  if not next(phelper.askedspells) then
    return "None"
  else
    local ttable = {}
    for i,v in ipairs(phelper.askedspells) do
      local tstring = v.sn
      if v.disabled then
        tstring = tstring .. " (disabled)"
      end
      table.insert(ttable, tstring)
    end
    return table.concat (ttable, ", ")
  end
end


]]>
</script>

<script>
<![CDATA[

--stats.vitals { "hp": 5280, "mana": 4390, "moves": 5185 }
--stats.stats { "str": 233, "int": 177, "wis": 213, "dex": 329, "con": 181, "luck": 245, "hr": 309, "dr": 371, "saves": 51 }
--stats.maxstats { "maxhp": 5280, "maxmana": 4390, "maxmoves": 5185, "maxstr": 110, "maxint": 100, "maxwis": 131, "maxdex": 182, "maxcon": 108, "maxluck": 157 }
--stats.worth { "gold": 322802, "bank": 0, "qp": 5257, "tp": 2, "trains": 1, "pracs": 3 }
--stats.status { "level": 180, "tnl": 1428, "hunger": 70, "thirst": 70, "align": 74, "state": 8, "pos": "Fighting" , "enemy": "a mountain cyclops", "enemypct": 12 }
--stats.base { "name": "Bast", "class": "Thief", "subclass": "Ninja", "race": "Shadow", "clan": "", "pretitle": "", "perlevel": 5000 }
function OnPluginBroadcast (msg, id, name, text)
  phelper:OnPluginBroadcast(msg, id, name, text)
  
  local old_mana = -1
  local old_moves = -1
  local old_state = -1
  if stats and stats.vitals then
    old_mana = tonumber(stats.vitals.mana)
    old_moves = tonumber(stats.vitals.moves)
  end
  if stats and stats.status then
    old_state = tonumber(stats.status.state)
  end
  if id == '3e7dedbe37e44942dd46d264' then
    if text:find("char") then
      res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char")
      local tt = assert (loadstring ('return ' .. gmcparg or ""))()
      if tt['vitals'] and tt['stats'] and tt['maxstats'] and tt['worth'] and tt['status'] and tt['base'] then
        stats = tt
        if tonumber(stats.vitals.mana) > old_mana then
          -- more mana
          need_mana = false
          nextspellup('more mana')
        end
        if tonumber(stats.vitals.moves) > old_moves then
          -- more moves
          need_moves = false
          nextspellup('more moves')
        end
        if tonumber(stats.status.state) == 3 and old_state ~= 3 then
          -- state changed to active from something else
          nextspellup('state change to active')
        end
      end

    end
    if text:find("room.info") then
      res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
      local tt = assert (loadstring ('return ' .. gmcparg or ""))()
      current_room = tt.num
      if nocast_rooms[current_room] then
        phelper:mdebug('setting nocast true for', current_room, tt.name)
        nocast = true
      else
        if nocast then
          nocast = false
          nextspellup('left nocast room')
        end
      end      
    end
  end
  if id == 'aaa72f3b5453567e2bba9d50' then
    if msg == 5 then          
      -- spell casting failure    
      local tag = assert (loadstring ('return ' .. text or ""))()
      --tprint(tag)
      if tonumber(tag.sn) == waiting then
        waiting = false
      end
      if tag.reason == 1 then    
        if askedspells_xref[tonumber(tag.sn)] ~= nil then
          nextspellup('spell fail')            
        end
      elseif tag.reason == 4 then
        need_mana = true
      elseif tag.reason == 5 then
        nocast_rooms[current_room] = true
        nocast = true
      elseif tag.reason == 8 then
        -- remove from askedspells list
      elseif tag.reason == 11 then
        -- remove from askedspells list
      elseif tag.reason == 12 then
        need_moves = true
      end
    elseif msg == 7 then          
      -- slist all    
      spells['all'] = assert (loadstring ('return ' .. text or ""))()
      load_spells_xrefs()      
      if spells['all'] and spells['affected'] and recoveries['affected'] then
        --print("have slist")
        have_slist = true
        nextspellup('have slist')
      end
      
    elseif msg == 8 then          
      -- slist learned
      spells['learned'] = assert (loadstring ('return ' .. text or ""))()
      
    elseif msg == 9 then          
      -- slist spellups
      spells['spellup'] = assert (loadstring ('return ' .. text or ""))()

    elseif msg == 10 then          
      -- slist affected
      spells['affected'] = assert (loadstring ('return ' .. text or ""))()
      if waiting then
        if spells['affected'][waiting] then
          waiting = false
        end
      end
      if spells['all'] and spells['affected'] and recoveries['affected'] then
        --print('have slist')
        have_slist = true
      end
      noneed=false
      nextspellup('spells affected change')
    elseif msg == 11 then          
      -- recoveries all
      recoveries['all'] = assert (loadstring ('return ' .. text or ""))()

    elseif msg == 12 then          
      -- recoveries affected
      recoveries['affected'] = assert (loadstring ('return ' .. text or ""))()
      noneed=false
      if spells['all'] and spells['affected'] and recoveries['affected'] then
        --print('have slist')
        have_slist = true
      end      
      nextspellup('recovery affected change')
    end  
    
  end
end

function OnPluginInstall ()
  --OnPluginEnable is automatically called by pluginhelper

  phelper:OnPluginInstall()
end -- OnPluginInstall

function OnPluginClose ()
  --OnPluginDisable is automatically called by pluginhelper

  phelper:OnPluginClose()
end -- OnPluginClose

function OnPluginEnable ()
  ldplugin ("aard_GMCP_handler", "3e7dedbe37e44942dd46d264")
  ldplugin ("broadcast_spellsskills", "aaa72f3b5453567e2bba9d50")

  phelper:OnPluginEnable()
  if IsConnected() then
    load_spells("all")
    load_spells_xrefs()
    load_spells("affected")
    load_spells("spellup")
    load_spells("learned")
    load_recoveries("all")
    load_recoveries("affected")
    if spells['all'] and spells['affected'] and recoveries['affected'] then
      --print("have slist")
      have_slist = true
    end
    CallPlugin("3e7dedbe37e44942dd46d264","Send_GMCP_Packet","request char")    
  end
  
  if askedspells_xref == nil then
    make_askedspells_xrefs ()
  end
end -- OnPluginEnable

function OnPluginDisable ()
  if GetPluginInfo(GetPluginID (), 17) and IsConnected() then
    --TelnetOptionOff (TELOPT_SPELLUP)
    --TelnetOptionOff (TELOPT_SKILLGAINS)
  end

  phelper:OnPluginDisable()
end -- OnPluginDisable

function OnPluginConnect ()
  TelnetOptionOn (TELOPT_SPELLUP)
  TelnetOptionOn (TELOPT_SKILLGAINS)

  phelper:OnPluginConnect()
end -- function OnPluginConnect

function OnPluginDisconnect ()

  phelper:OnPluginDisconnect()
end -- function OnPluginConnect

function OnPluginSaveState ()

  phelper:OnPluginSaveState()
end -- function OnPluginSaveState

]]>
</script>

<script>
<![CDATA[

phelper:set_default('cmd', 'bspell')
phelper:set_default('plugin_colour', 'lime')

phelper:add_setting( 'askedspells', {type="table", help="the list of spells", default=serialize.save_simple({}), sortlev=35, istable=true, formatfunc=formatspells, readonly=true, afterf=make_askedspells_xrefs})
phelper:add_setting( 'pause', {type="bool", help="pause spellup", default=false, sortlev=35, readonly=true})

phelper:add_pobject('win', spellwin)

phelper:add_cmd('listspells', {func=cmd_listspells, help="list request spells", default=true})
phelper:add_cmd('add', {func=cmd_addspell, help="add a spell"})
phelper:add_cmd('pause', {func=cmd_pause, help="pause spellup"})
phelper:add_cmd('resume', {func=cmd_resume, help="resume spellup"})
phelper:add_cmd('delete', {func=cmd_deletespell, help="remove a spell"})
phelper:add_cmd('disable', {func=cmd_disable, help="disable a spell"})
phelper:add_cmd('enable', {func=cmd_enable, help="enable a spell"})
phelper:add_cmd('ablock', {func=cmd_ablocker, help="add blockers, Ex. 'protection good:inertial barrier'"})
phelper:add_cmd('dblock', {func=cmd_dblocker, help="remove blockers"})
phelper:add_cmd('refresh', {func=cmd_refresh, help="refresh affected spells"})
phelper:add_cmd('fast', {func=cmd_fast, help="cast all spells in one go"})

phelper:enable()

--phelper:addaardhelps{"Map", "Automap", "Maprun", "Maptags", "Speedwalks", "Academy-Geography"}
--phelper:addaardcmds{"map", "automap", "maprun", "tags", "runto"}

]]>
</script>
</muclient>
