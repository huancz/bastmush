<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- $Id$ -->
<muclient>
<plugin
   name="bast_spellup"
   author="Bast"
   id="aaaf0c555a44169e0f1d9674"
   language="Lua"
   purpose="Bast's spellup plugin"
   date_written="2008-07-18"
   requires="4.52"
   version="6.0"
   save_state="y"
   >
<description trim="y">
bspell slist      --> list requested self spells
  
bspell sa all         --> cast all possible spellups
bspell sr all         --> remove all spellups

bspell sa blur  "champion's strength:3"    --> add more to the current list
  to add a spell in a certain place add a : then the place number
bspell sd "night vision" "detect magic"   --> remove those from the list

bspell sba   --> block a spell with another spell
                           (eg. bspell sba 68:121)
bspell sbr   --> remove a block
                           (eg. bspell sbr 68:121)

bspell sdisable --> disable a spell without taking it out of the list
bspell senable --> enabled a disabled self spell

bspell fast    --> cast all spellups immediately, as fast as you can

bspell olist      --> list requested other spells

bspell other (name) --> try to spellup another player with picked spellups
                          (eg. bspell other johnsmith)

bspell other (name) fast --> try to spellup another player with all spellups
                          (eg. bspell other johnsmith fast)

bspell oa aid --> add aid as a requested spellup on others
bspell or aid --> remove aid as a requested spellup on others

bspell odisable --> disable a requested other spell without taking it out of the list
bspell oenable --> enable a disabled other spell

bspell pause   --> stop casting spellups until a resume
bspell resume  --> resume casting
bspell refresh --> requery server for current spells on us

bspell info    --> request info about a spell, shows what the mudside slist returned
bspell export  --> export the spells you have requested and their settings
bspell togglespellup --> toggle a spell to be used as a spellup even if it isn't a mudside spellup spell

bspell help    --> this message

</description>

</plugin>

<!--  Triggers  -->
<triggers>


</triggers>


<!--  Script  -->

<script>
<![CDATA[
internalrevision = "$Rev$"

dofile (GetPluginInfo (GetPluginID (), 20) .. "luapath.lua")

require 'var'
require 'pluginhelper'
require "tprint"
require "commas"
require "serialize"
require "ldplugin"
require "findfile"
require "verify"
require "aardutils"
require "bastspell"
require "stringfuncs"

nfile = scan_dir_for_file (GetInfo(60), "telnet_options.lua")

if nfile then
  -- pull in telnet option handling
  dofile (nfile)
else
  print("Could not load telnet_options.lua, please copy it to your plugin directory")
end

stats = nil

-- phelper.askedself = list of tables with {sn, disabled, blocked}
-- phelper.askedother
askedself_xref = nil
askedother_xref = nil
noneed = false

-- things that can block spells
have_slist = false
waiting = false
need_moves = false
need_mana = false
nocast = falseq

current_room = -1


function getstatus()
  if phelper.pause then
    return "Paused"
  elseif need_mana then
    return "No mana"
  elseif need_moves then
    return "No moves"
  elseif nocast then
    return "Nocast"
  else
    return capitalize(statestrings[tonumber(stats.status.state)])
  end
end

function getaskedself()
  return serialize.save_simple(phelper.askedself or "")
end

function event_askedself_change()
  phelper:processevent('askedself_change', phelper.askedself)
end

function getaskedother()
  return serialize.save_simple(phelper.askedother or "")
end

function event_askedother_change()
  phelper:processevent('askedother_change', phelper.askedother)
end

function event_status_change()
  local status = getstatus()
  phelper:processevent('status_change', {status=status})
end

function setwaiting(twait)
  waiting = twait
  event_waiting_change()
end

function event_waiting_change()
  local status = getstatus()
  local twaiting = {waiting=waiting}
  if waiting == nil or waiting == false then
    twaiting = {waiting="false"}
  end
  phelper:processevent('waiting_change', twaiting)
end

function isblocked(sn)
  if phelper.askedself and askedself_xref[sn] and phelper.askedself[askedself_xref[sn]].blockers then
    for blocker, _ in pairs(phelper.askedself[askedself_xref[sn]].blockers) do
      if spells['affected'][blocker] then
        return true
      end
    end
  end
  return false
end

function add_blocker(spell, blocker)
  local aspell = find_spell(spell)
  local sn = -1
  if aspell then
    sn = tonumber(aspell.sn)
  else
    print('Add Blocker: could not find spell', spell)
    return false
  end
  local bspell = find_spell(blocker)
  local blksn = -1
  if bspell then
    blksn = tonumber(bspell.sn)
  else
    print('could not find spell', blocker)
    return false
  end
  if sn and blksn and askedself_xref[sn] and phelper.askedself[askedself_xref[sn]] then
    if phelper.askedself[askedself_xref[sn]] then
      if not phelper.askedself[askedself_xref[sn]].blockers then
        phelper.askedself[askedself_xref[sn]].blockers = {}
      end
      phelper.askedself[askedself_xref[sn]].blockers[blksn] = 1
      return true
    end
  end
  return false
end -- add_disabled

function remove_blocker(spell, blocker)
  local aspell = find_spell(spell)
  local sn = -1
  if aspell then
    sn = tonumber(aspell.sn)
  else
    print('Remove blocker: could not find spell', spell)
    return false
  end
  local bspell = find_spell(blocker)
  local blksn = -1
  if bspell then
    blksn = tonumber(bspell.sn)
  else
    print('could not find spell', blocker)
    return false
  end
  if sn and blksn and askedself_xref[sn] and phelper.askedself[askedself_xref[sn]] then
    if phelper.askedself[askedself_xref[sn]] then
      phelper.askedself[askedself_xref[sn]].blockers[blksn] = nil
    end
    return true
  end
  return false
end

function cmd_refresh(cmddict)
  setwaiting(false)
  noneed = false
  SendNoEcho("slist affected noprompt")
  ColourNote(RGBColourToName(var.plugin_colour), "black", "Refreshing affected spells and resetting events")
end

function make_askedself_xrefs ()
  phelper:mdebug('making askedself xref')
  askedself_xref = {}
  for k, v in pairs (phelper.askedself) do
    askedself_xref[v.sn] = k
  end -- for each spell
  event_askedself_change()  
end -- make_xrefs

function make_askedother_xrefs ()
  phelper:mdebug('making askedother xref')
  askedother_xref = {}
  for k, v in pairs (phelper.askedother) do
    askedother_xref[v.sn] = k
  end -- for each spell
  event_askedother_change()  
end -- make_xrefs

function activatespell(sn, fast)
  fast = verify_bool(fast)
  if phelper.askedself[askedself_xref[sn]] then
    v = phelper.askedself[askedself_xref[sn]]
    if not spells['affected'][sn] then
      local cast = true
      local recov = spells['all'][sn].recovery
      if recov and recoveries['affected'][recov] then
        cast = false
      end
      if v.disabled or isblocked(sn) or not spells['learned'][sn]  then
        cast = false
      end 
      if not spells['learned'][sn] then
        cast = false
      end
      if cast then
        if not fast then
          --print("setting waiting to", sn)
          setwaiting(tonumber(sn))
        end    
        if tonumber(spells['all'][sn]['type']) == 1 then
          SendNoEcho('cast ' .. tostring(sn))
        else
          words = justWords(spells['all'][sn].name)
          SendNoEcho(words[1])
        end
        return true
      end
    end
  end
  return false
end

function nextspellup (reason)
--  print("called nextspellup", reason, waiting)
  if have_slist and 
     stats ~= nil and 
     not waiting and 
     not need_mana and 
     not need_moves and 
     not noneed and
     not nocast and
     not phelper.pause and
     tonumber(stats.status.state) == 3 then
     
    --print('got to go through table')
    for k,v in ipairs(phelper.askedself) do
      if activatespell(v.sn) then
        return
      end
    end
    noneed = true
    
  end
end

function formatheader()
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format("%-30s", "#. Name"),
             "yellow",          "black", string.format("%-3s", " P "), 
             "seagreen",        "black", string.format("%-3s", " B "), 
             "orange",          "black", string.format("%-3s", " D "), 
             "orange",          "black", string.format("%-4s", " NP "), 
             "orange",          "black", string.format("%-4s", " NL "))
  ColourNote(RGBColourToName(var.plugin_colour), "black",   "____________________________________________________")
end

function formatspell(spell, colour)
  if not colour then
    colour = var.plugin_colour
  end
  local name = spells['all'][spell.sn].name
  local disabled = ""
  local blocked = ""
  local tstring = ""
  if spell.disabled then
    disabled = "Yes"
  end
  if spell.blockers then
    for sn,t in pairs(spell.blockers) do
      blocked = blocked .. " " .. spells['all'][sn].name
    end
  end  
  ColourNote(RGBColourToName(colour), "black", string.format("%-25s" , name),
             RGBColourToName(colour), "black", string.format("%-5s" , spell.sn),
             RGBColourToName(colour), "black", string.format("%-10s", disabled),
             RGBColourToName(colour), "black", string.format("%-10s", blocked))
end

function cmd_slist(cmddict)
  phelper:plugin_header("Spells requested (" .. tostring(#phelper.askedself) .. ")")
  if waiting then
    ColourNote(RGBColourToName(var.plugin_colour), "black", "Waiting: " .. spells['all'][waiting].name .. " (" .. waiting .. ")")  
  end  
  formatheader()
  local tnoprac = {}
  local tgood = {}
  local tdisable = {}
  count = 0
  for i,j in ipairs(phelper.askedself) do
    count = count + 1
    local v = spells['all'][tonumber(j.sn)]
    local noprac = "   "
    local nolearn = "   "
    local disabled = "   "
    local blocked = "   "
    local pending = "   "
    local blockedby = "   "
    if spells['notpracticed'][tonumber(v.sn)] then
      noprac = " NP "  
    elseif spells['notlearned'][tonumber(v.sn)] then
      nolearn = " NL "
    end
    if j.blockers then
      for blocker, _ in pairs(j.blockers) do
        if not spells['affected'][tonumber(v.sn)] and spells['affected'][blocker] then
          blocked = " B "
          blockedby = "  Blocked by spell: " .. spells['affected'][blocker].name
        end
      end
    end
    local trec = spells['all'][tonumber(j.sn)].recovery
    if trec and recoveries['affected'][tonumber(trec)] then
      blocked = " B "
      blockedby = "  Blocked by Recovery: " .. recoveries['affected'][tonumber(trec)].name
    end
    if j.disabled then
      disabled = " D "
    end  
    if not spells['affected'][tonumber(v.sn)] and not j.disabled and not (v.percent <= 1) and blocked == "   " then
      pending = " P "
    end
    
    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format("%-30s", count .. ". " .. v.name),
               "yellow", "black", string.format("%-3s", pending), 
               "seagreen",  "black", string.format("%-3s", blocked), 
               "orange", "black", string.format("%-3s", disabled), 
               "orange", "black", string.format("%-4s", noprac), 
               "orange", "black", string.format("%-4s", nolearn),
               "orange", "black", blockedby)
  end
end

function cmd_pause(cmddict)
  phelper:plugin_header("Spellup Paused")
  --ColourNote(RGBColourToName(var.plugin_colour), "black", "Spellup Paused")
  phelper.pause = true
  event_status_change()  
end

function cmd_resume(cmddict)
  phelper:plugin_header("Spellup Resumed")
  --ColourNote(RGBColourToName(var.plugin_colour), "black", "Spellup Resumed")
  phelper.pause = false
  noneed = false
  event_status_change()  
  nextspellup("resumed")
end

function cmd_sablocker(cmddict)
  if #cmddict >= 1 then
    local ablocked = false
    phelper:plugin_header()    
    for i,item in ipairs(cmddict) do
      local place = nil
      colonplace, _ = string.find(item, ':')
      if colonplace and colonplace > 0 then
        tlist = utils.split(item, ':')
        local spell = tlist[1]
        local blck = tlist[2]
        spell = find_spell(spell)
        blck = find_spell(blck)
        local test = add_blocker(spell.sn, blck.sn)
        if test then
          ablocked = true
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(spell.sn)].name .. " is now blocked by " .. spells['all'][tonumber(blck.sn)].name)
        end
      end
    end
    if ablocked then
      event_askedself_change()
    end
  end
  return true
end

function cmd_sdblocker(cmddict)
  if #cmddict >= 1 then
    local rblocked = false
    phelper:plugin_header()    
    for i,item in ipairs(cmddict) do
      local place = nil
      colonplace, _ = string.find(item, ':')
      if colonplace and colonplace > 0 then
        tlist = utils.split(item, ':')
        sn = tlist[1]
        blck = tlist[2]
        if remove_blocker(sn, blck) then
          rblocked = true
        end
      end
    end
    if rblocked then
      event_askedself_change()
    end    
  end
  return true
end


function cmd_sdisable(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()   
    local disabled = false
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        local sn = tonumber(aspell.sn)
        if sn then
          if askedself_xref[sn] ~= nil then
            phelper.askedself[askedself_xref[sn]].disabled = true
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " disabled")    
            disabled = true
          else
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")      
          end
        end
      else
        print('Disable: could not find spell', item)
      end
    end
    if disabled then
      event_askedself_change()
    end
  end
end

function cmd_senable(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()   
    local enabled = false
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        local sn = tonumber(aspell.sn)
        if sn then
          if askedself_xref[sn] ~= nil then
            phelper.askedself[askedself_xref[sn]].disabled = false
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " enabled")          
            enabled = true
          else
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")      
          end
        end
      else
        print('Enable: could not find spell', item)      
      end
    end
    if enabled then
      noneed = false
      event_askedself_change()      
      nextspellup("spells enabled")
    end
  end
end

function cmd_export(cmddict)
  local tdict = {}
  local tblock = {}
  local tdisabled = {}
  for i,v in ipairs(phelper.askedself) do
    table.insert(tdict, tostring(v.sn))
    if v.disabled then
      table.insert(tdisabled, tostring(v.sn))
    end
    if v.blockers then
      for f,u in pairs(v.blockers) do
        table.insert(tblock, tostring(v.sn) .. ':' .. tostring(f))
      end
    end
  end
  ColourNote(RGBColourToName(var.plugin_colour), "black", phelper.cmd .. " sremove all")
  ColourNote(RGBColourToName(var.plugin_colour), "black", phelper.cmd .. " sadd " .. table.concat(tdict, " "))
  local tstring = ""
  if next(tblock) then
    local tblocks = phelper.cmd .. " sba " .. table.concat(tblock, " ")
    ColourNote(RGBColourToName(var.plugin_colour), "black", tblocks)    
  end
  if next(tdisabled) then
    local tdis = phelper.cmd .. " sdisable " .. table.concat(tdisabled, " ")
    ColourNote(RGBColourToName(var.plugin_colour), "black", tdis)    
  end
  local tdict = {}
  local tdisabled = {}
  for i,v in ipairs(phelper.askedother) do
    if v.disabled then
      table.insert(tdisabled, tostring(v.sn))    
    end
    table.insert(tdict, tostring(v.sn))
  end
  ColourNote(RGBColourToName(var.plugin_colour), "black", phelper.cmd .. " oremove all")
  ColourNote(RGBColourToName(var.plugin_colour), "black", phelper.cmd .. " oadd " .. table.concat(tdict, " "))
  if next(tdisabled) then
    local tdis = phelper.cmd .. " odisable " .. table.concat(tdisabled, " ")
    ColourNote(RGBColourToName(var.plugin_colour), "black", tdis)    
  end
  
end

function formatitem(row, data)
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format('%-20s: %s', tostring(row), tostring(data)))
end

function cmd_info(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header('Info')
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        formatitem("Name", aspell.name)
        formatitem("SN", aspell.sn)
        formatitem("Type", aspell.type)
        formatitem("Target", spelltarget_table[tonumber(aspell.target)])
        formatitem("Prac %", aspell.percent)
        if aspell.spellup == 1 then
          formatitem("Spellup", "Yes")
        else
          formatitem("Spellup", "No")
        end          
        if aspell.clientspellup == 1 then
          formatitem("Client Spellup", "Yes")
        else
          formatitem("Client Spellup", "No")
        end          
        if aspell.recovery ~= -1 then
          formatitem("Recovery", recoveries['all'][aspell.recovery].name)
        end
        local tstring = "No"
        local blockers = ""
        if askedself_xref[aspell.sn] and phelper.askedself[askedself_xref[aspell.sn]] then
          tstring = "Yes"
          if phelper.askedself[askedself_xref[aspell.sn]].disabled then
            tstring = tstring .. " - Disabled"
          end
          if phelper.askedself[askedself_xref[aspell.sn]].blockers then
            for i,v in pairs(phelper.askedself[askedself_xref[aspell.sn]].blockers) do
              if blockers == "" then
                blockers = spells['all'][i].name
              else
                blockers = blockers .. ", " .. spells['all'][i].name
              end
            end
          end
        end
        formatitem("Requested", tstring)
        if blockers ~= "" then
          formatitem("Blockers", blockers)
        end
        if spells['affected'][aspell.sn] and spells['affected'][aspell.sn].duration then
          formatitem("Duration", SecondsToClock(spells['affected'][aspell.sn].finish - GetInfo(304)))
        end
        ColourNote("black","black", "")
      else
        print('Info: could not find spell', item)
      end
    end
  end
end

function cmd_togglespellup(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header("Toggle Spellup")
    local sspells = {}
    local uspells = {}
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        if aspell.clientspellup == 0 or not aspell.clientspellup then
          sspells[aspell.sn] = aspell
          aspell.clientspellup = 1
          ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " set to be a spellup.")                
        else
          uspells[aspell.sn] = aspell
          aspell.clientspellup = 0
          ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " is no longer a spellup.")        
        end      
      end
    end
    local res, text = CallPlugin("aaa72f3b5453567e2bba9d50", "setclientspellup", serialize.save_simple(sspells))
    local res, text = CallPlugin("aaa72f3b5453567e2bba9d50", "unsetclientspellup", serialize.save_simple(uspells))    
  end
end

function cmd_fast(cmddict)
  for i,v in ipairs(phelper.askedself) do
    activatespell(tonumber(v.sn), true)
  end
end

function cmd_other(cmddict)
  local who = cmddict[1]

  if not who then
    ColourNote ("red", "", "You did not specify a target!")
    return
  end
  if cmddict[2] == 'fast' then
    print('got fast')
    for sn, v in pairs (spells['spellup']) do
      if spells['learned'][tonumber(v.sn)] and   -- we know it
        v.spellup == 1 and       -- it is a spellup
        v.target == 2 and   -- can be cast on others
        v.type == 1 then   -- spell not skill
          Send ("cast " .. tostring(v.sn) .. " " .. who)  -- cast it
      end -- if possible to spellup this one
    end -- for
  else
    for i, v in ipairs(phelper.askedother) do
      if spells['learned'][tonumber(v.sn)] and   -- we know it
        spells['all'][v.sn].spellup == 1 and       -- it is a spellup
        spells['all'][v.sn].target == 2 and   -- can be cast on others
        spells['all'][v.sn].type == 1 then   -- spell not skill
          Send ("cast " .. tostring(v.sn) .. " " .. who)  -- cast it   
      end
    end
  end
end

function cmd_oadd(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header("Added spells to be cast on others")
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        local sn = tonumber(aspell.sn)
        --tprint(sn)
        if sn then            
          if aspell.spellup ~= 1 and aspell.clientspellup ~= 1 then
            ColourNote ("red", "", "Spell '" .. aspell.name .. "' is not a spellup.")
          else
            if cancastother(sn) then
              --tprint(askedother_xref)
              if askedother_xref == nil or askedother_xref[tonumber(sn)] == nil then
                if aspell.percent == 1 then
                  ColourNote ("red", "", "You have not practiced '" .. aspell.name .. "', but it will be added anyway, it will not be cast until practiced")
                elseif aspell.percent == 0 then
                  ColourNote ("red", "", "You have not learned '" .. aspell.name .. "', but it will be added anyway, it will not be cast until practiced")
                end                  
                phelper:mdebug('adding ', item, sn, aspell.name)                
                table.insert(phelper.askedother, {sn=tonumber(sn)})
                make_askedother_xrefs()                
                ColourNote(RGBColourToName(var.plugin_colour), "black", "Added " .. aspell.name)
              else
                ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " already in list")
              end
            else
              ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " cannot be cast on another")
            end  
          end
        else
          print('Add spell: could not find', item)
        end
      end
    end
  end
end

function cmd_oremove(cmddict)
  if #cmddict >= 1 then
    removed = false
    phelper:plugin_header("Removed spells to be cast on others")   
    if cmddict[1] == 'all' then
      phelper.askedother = {}
      make_askedother_xrefs()
      ColourNote(RGBColourToName(var.plugin_colour), "black", "All spells removed")
    else
      for i,item in ipairs(cmddict) do
        local aspell = find_spell(item)
        if aspell then
          local sn = tonumber(aspell.sn)
          if sn then
            if askedother_xref[sn] ~= nil then
              table.remove(phelper.askedother, askedother_xref[sn])
              ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " removed")
              removed = true
            else
              ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")      
            end
          end
        else
          print('Delete Spell: could not find spell', item)
        end  
      end
      if removed then
        make_askedother_xrefs()
      end
    end
  end
end

function cmd_odisable(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()   
    local disabled = false
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        local sn = tonumber(aspell.sn)
        if sn then
          if askedother_xref[sn] ~= nil then
            phelper.askedother[askedother_xref[sn]].disabled = true
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " disabled for casting on others")    
            disabled = true
          else
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")      
          end
        end
      else
        print('Disable: could not find spell', item)
      end
    end
    if disabled then
      event_askedother_change()
    end
  end
end

function cmd_oenable(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()   
    local enabled = false
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        local sn = tonumber(aspell.sn)
        if sn then
          if askedother_xref[sn] ~= nil then
            phelper.askedother[askedother_xref[sn]].disabled = false
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " enabled for casting on others")          
            enabled = true
          else
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")      
          end
        end
      else
        print('Enable: could not find spell', item)      
      end
    end
    if enabled then
      event_askedother_change()      
    end
  end
end


function formatotherheader()
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format("%-30s", "#. Name"),
             "orange",          "black", string.format("%-3s", " D "), 
             "orange",          "black", string.format("%-4s", " NP "), 
             "orange",          "black", string.format("%-4s", " NL "))
  ColourNote(RGBColourToName(var.plugin_colour), "black",   "____________________________________________________")
end


function cmd_olist(cmddict)
  phelper:plugin_header("Spells requested for others (" .. tostring(#phelper.askedother) .. ")")
  formatotherheader()
  local tnoprac = {}
  local tgood = {}
  local tdisable = {}
  local count = 0
  for i,j in ipairs(phelper.askedother) do
    count = count + 1
    local v = spells['all'][tonumber(j.sn)]
    local noprac = "   "
    local nolearn = "   "
    local disabled = "   "
    local blocked = "   "
    local pending = "   "
    if spells['notpracticed'][tonumber(v.sn)] then
      noprac = " NP "  
    elseif spells['notlearned'][tonumber(v.sn)] then
      nolearn = " NL "
    end
    if j.disabled then
      disabled = " D "
    end  
    
    ColourNote(RGBColourToName(var.plugin_colour), "black", string.format("%-30s", count .. ". " .. v.name),
               "orange", "black", string.format("%-3s", disabled), 
               "orange", "black", string.format("%-4s", noprac), 
               "orange", "black", string.format("%-4s", nolearn))
  end
end

function cmd_sremove(cmddict)
  if #cmddict >= 1 then
    removed = false
    phelper:plugin_header()   
    if cmddict[1] == 'all' then
      phelper.askedself = {}
      make_askedself_xrefs()
      ColourNote(RGBColourToName(var.plugin_colour), "black", "All spells removed")
    else
      for i,item in ipairs(cmddict) do
        local aspell = find_spell(item)
        if aspell then
          local sn = tonumber(aspell.sn)
          if sn then
            if askedself_xref[sn] ~= nil then
              table.remove(phelper.askedself, askedself_xref[sn])
              ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " removed")
              removed = true
            else
              ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")      
            end
          end
        else
          print('Delete Spell: could not find spell', item)
        end  
      end
      if removed then
        make_askedself_xrefs()
      end
    end
  end
end

function cmd_sadd(cmddict)
  if #cmddict >= 1 then
    local added = false
    phelper:plugin_header()
    if cmddict[1] == 'all' then
      if next(phelper.askedself) then
          ColourNote(RGBColourToName(var.plugin_colour), "black", "You have requested to add all spellups, if you want to use all please remove all requested spellups ")        
          return
      end
      phelper.askedself = {}    
      for i,v in pairs(spells['spellup']) do
        if spells['learned'][tonumber(v.sn)] then
          ColourNote(RGBColourToName(var.plugin_colour), "black", "Added " .. v.name)
          table.insert(phelper.askedself, {sn=tonumber(i)})          
        end
      end
      ColourNote(RGBColourToName(var.plugin_colour), "black", "All spells added")
      make_askedself_xrefs()
      nextspellup("added new spells")   
    else    
      for i,item in ipairs(cmddict) do
        local place = nil
        colonplace, _ = string.find(item, ':')
        if colonplace and colonplace > 0 then
          tlist = utils.split(item, ':')
          item = tlist[1]
          place = tlist[2]
        end
        local aspell = find_spell(item)
        if aspell then
          local sn = tonumber(aspell.sn)
          if sn then            
            if aspell.spellup ~= 1 and aspell.clientspellup ~= 1 then
              ColourNote ("red", "", "Spell '" .. aspell.name .. "' is not a spellup.")
            else
              if askedself_xref[tonumber(sn)] == nil then
                if aspell.percent == 1 then
                  ColourNote ("red", "", "You have not practiced '" .. aspell.name .. "', but it will be added anyway, it will not be cast until practiced")
                elseif aspell.percent == 0 then
                  ColourNote ("red", "", "You have not learned '" .. aspell.name .. "', but it will be added anyway, it will not be cast until practiced")
                end                  
                phelper:mdebug('adding ', item, sn, aspell.name, place)                
                local pos = -1
                if place then
                  table.insert(phelper.askedself,place, {sn=tonumber(sn)})
                  pos = tostring(place)
                else
                  table.insert(phelper.askedself, {sn=tonumber(sn)})
                  pos = tostring(#phelper.askedself)
                end
                make_askedself_xrefs()                
                added = true
                ColourNote(RGBColourToName(var.plugin_colour), "black", "Added " .. aspell.name .. " in position " .. pos)
              else
                ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " already in list")
              end
            end -- if
          else
            print('Add spell: could not find', item)
          end
        end
      end -- if number orname found
      if added then
        noneed = false
        --make_askedself_xrefs()
        nextspellup("added new spells")
      end
    end
  end
end

function formatspells()
  if not next(phelper.askedself) then
    return "None"
  else
    local ttable = {}
    for i,v in ipairs(phelper.askedself) do
      local tstring = v.sn
      if v.disabled then
        tstring = tstring .. " (disabled)"
      end
      table.insert(ttable, tstring)
    end
    return table.concat (ttable, ", ")
  end
end

function formatother()
  if not next(phelper.askedother) then
    return "None"
  else
    local ttable = {}
    for i,v in ipairs(phelper.askedother) do
      local tstring = v.sn
      if v.disabled then
        tstring = tstring .. " (disabled)"
      end
      table.insert(ttable, tstring)
    end
    return table.concat (ttable, ", ")
  end
end
]]>
</script>

<script>
<![CDATA[

--stats.vitals { "hp": 5280, "mana": 4390, "moves": 5185 }
--stats.stats { "str": 233, "int": 177, "wis": 213, "dex": 329, "con": 181, "luck": 245, "hr": 309, "dr": 371, "saves": 51 }
--stats.maxstats { "maxhp": 5280, "maxmana": 4390, "maxmoves": 5185, "maxstr": 110, "maxint": 100, "maxwis": 131, "maxdex": 182, "maxcon": 108, "maxluck": 157 }
--stats.worth { "gold": 322802, "bank": 0, "qp": 5257, "tp": 2, "trains": 1, "pracs": 3 }
--stats.status { "level": 180, "tnl": 1428, "hunger": 70, "thirst": 70, "align": 74, "state": 8, "pos": "Fighting" , "enemy": "a mountain cyclops", "enemypct": 12 }
--stats.base { "name": "Bast", "class": "Thief", "subclass": "Ninja", "race": "Shadow", "clan": "", "pretitle": "", "perlevel": 5000 }
function OnPluginBroadcast (msg, id, name, text)
  phelper:OnPluginBroadcast(msg, id, name, text)
  
  local old_mana = -1
  local old_moves = -1
  local old_state = -1
  if stats and stats.vitals then
    old_mana = tonumber(stats.vitals.mana)
    old_moves = tonumber(stats.vitals.moves)
  end
  if stats and stats.status then
    old_state = tonumber(stats.status.state)
  end
  if id == '3e7dedbe37e44942dd46d264' then
    if text:find("char") then
      res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char")
      local tt = assert (loadstring ('return ' .. gmcparg or ""))()
      if tt['vitals'] and tt['stats'] and tt['maxstats'] and tt['worth'] and tt['status'] and tt['base'] then
        stats = tt
        if tonumber(stats.vitals.mana) > old_mana then
          -- more mana
          need_mana = false
          event_status_change()           
          nextspellup('more mana')
        end
        if tonumber(stats.vitals.moves) > old_moves then
          -- more moves
          need_moves = false
          event_status_change()           
          nextspellup('more moves')
        end
        if tonumber(stats.status.state) == 3 and old_state ~= 3 then
          -- state changed to active from something else     
          nextspellup('state change to active')
        end
        if old_state ~= tonumber(stats.status.state) then
          event_status_change()        
        end
      end

    end
    if text:find("room.info") then
      res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
      local tt = assert (loadstring ('return ' .. gmcparg or ""))()
      current_room = tt.num
      if phelper.nocast_rooms[tonumber(current_room)] then
        phelper:mdebug('setting nocast true for', current_room, tt.name)
        nocast = true
        event_status_change()
      else
        if nocast then
          nocast = false
          event_status_change()
          nextspellup('left nocast room')
        end
      end      
    end
  end
  if id == 'aaa72f3b5453567e2bba9d50' then
    if msg == 5 then          
      -- spell casting failure    
      local tag = assert (loadstring ('return ' .. text or ""))()
      if tag.reason == 1 then
        if askedself_xref[tonumber(tag.sn)] ~= nil then
          setwaiting(false)
          nextspellup('spell fail')            
        end
      elseif tag.reason == 2 then    
        local tagsn = tonumber(tag.sn)
        if askedself_xref[tonumber(tag.sn)] ~= nil then
          local tagsn = tonumber(tag.sn)
          if tagsn == waiting then
            phelper.askedself[askedself_xref[tagsn]].disabled = true
            ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tagsn].name .. " disabled because the affect already exists.")
            make_askedself_xrefs()
            setwaiting(false)
            nextspellup('spell fail')            
          end
        end 
      elseif tag.reason == 3 then
        setwaiting(false      )
        nextspellup('spell fail')          
      elseif tag.reason == 4 then
        setwaiting(false)
        need_mana = true
        event_status_change()
      elseif tag.reason == 5 then
        phelper.nocast_rooms[tonumber(current_room)] = true
        nocast = true
        setwaiting(false)
        event_status_change()
      elseif tag.reason == 6 then
        setwaiting(false)
      elseif tag.reason == 8 then
        -- remove from askedself list
      elseif tag.reason == 10 then
        setwaiting(false)
      elseif tag.reason == 11 then
        -- remove from askedself list
        local tagsn = tonumber(tag.sn)
        if tagsn == waiting then        
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tagsn].name .. " disabled because it is disabled mudside.")
          phelper.askedself[askedself_xref[tagsn]].disabled = true
          setwaiting(false)
        end
      elseif tag.reason == 12 then
        need_moves = true
        setwaiting(false)
        event_status_change()        
      end
    elseif msg == 7 then          
      -- all spells  
      load_spells('all')
      if spells['all'] and recoveries['all'] then
        --print("have slist")
        have_slist = true
        nextspellup('have slist')
      end
      
    elseif msg == 8 then          
      -- learned spells
      load_spells('learned')
      load_spells('notlearned')
      load_spells('notpracticed')      
      noneed = false
      nextspellup('learned change')
      
    elseif msg == 9 then          
      -- spellup spells
      load_spells('spellup', true)
      
    elseif msg == 10 then          
      -- affected spells
      load_spells('affected')
      if waiting then
        if spells['affected'][waiting] then
          setwaiting(false)
        end
      end
      if spells['all'] and recoveries['all'] then
        --print('have slist')
        have_slist = true
      end
      noneed=false
      nextspellup('spells affected change')
      
    elseif msg == 11 then          
      -- recoveries all
      load_recoveries('all')
      
    elseif msg == 12 then          
      -- recoveries affected
      load_recoveries('affected')
      noneed=false
      if spells['all'] and recoveries['all'] then
        --print('have slist')
        have_slist = true
      end      
      nextspellup('recovery affected change')
      
    end  
    
  end
end

function OnPluginInstall ()
  --OnPluginEnable is automatically called by pluginhelper

  phelper:OnPluginInstall()
end -- OnPluginInstall

function OnPluginClose ()
  --OnPluginDisable is automatically called by pluginhelper

  phelper:OnPluginClose()
end -- OnPluginClose

function OnPluginEnable ()
  ldplugin ("aard_GMCP_handler", "3e7dedbe37e44942dd46d264")
  ldplugin ("broadcast_spellsskills", "aaa72f3b5453567e2bba9d50")

  phelper:OnPluginEnable()
  if IsConnected() then
    load_spells("all")
    --load_spells_xrefs()
    load_spells("affected")
    load_spells("spellup", true)
    load_spells("learned")
    load_spells("notpracticed")
    load_spells("notlearned")
    --print('loading recoveries in enable')
    load_recoveries("all")
    load_recoveries("affected")
    if spells['all'] and recoveries['all'] and recoveries['affected'] and spells['affected'] and spells['learned'] then
      --print("have slist")
      have_slist = true
      nextspellup('has slist')
    end
    CallPlugin("3e7dedbe37e44942dd46d264","Send_GMCP_Packet","request char")    
  end
  
  if askedself_xref == nil then
    make_askedself_xrefs ()
  end
  if askedother_xref == nil then
    make_askedother_xrefs ()
  end
end -- OnPluginEnable

function OnPluginDisable ()
  if GetPluginInfo(GetPluginID (), 17) and IsConnected() then
    --TelnetOptionOff (TELOPT_SPELLUP)
    --TelnetOptionOff (TELOPT_SKILLGAINS)
  end

  phelper:OnPluginDisable()
end -- OnPluginDisable

function OnPluginConnect ()
  TelnetOptionOn (TELOPT_SPELLUP)
  TelnetOptionOn (TELOPT_SKILLGAINS)

  phelper:OnPluginConnect()
end -- function OnPluginConnect

function OnPluginDisconnect ()

  phelper:OnPluginDisconnect()
end -- function OnPluginConnect

function OnPluginSaveState ()

  phelper:OnPluginSaveState()
end -- function OnPluginSaveState

]]>
</script>

<script>
<![CDATA[

phelper:set_default('cmd', 'bspell')
phelper:set_default('plugin_colour', 'lime')

phelper:add_setting( 'askedself', {type="table", help="the list of spells to use on self", default=serialize.save_simple({}), sortlev=35, istable=true, formatfunc=formatspells, readonly=true, afterf=make_askedself_xrefs})
phelper:add_setting( 'askedother', {type="table", help="the list of spells to use on other", default=serialize.save_simple({}), sortlev=35, istable=true, formatfunc=formatother, readonly=true, afterf=make_askedother_xrefs})
phelper:add_setting( 'nocast_rooms', {type="table", help="the list of rooms that are nocast", default=serialize.save_simple({}), sortlev=35, istable=true, readonly=true})
phelper:add_setting( 'pause', {type="bool", help="pause spellup", default=false, sortlev=35, readonly=true})

phelper:add_cmd('slist', {func=cmd_slist, help="list requested spells", default=true})
phelper:add_cmd('sadd', {func=cmd_sadd, help="add a spell, use 'all' to add all spellups"})
phelper:add_cmd('sremove', {func=cmd_sremove, help="remove a spell, use 'all' to clear table"})
phelper:add_cmd('sdisable', {func=cmd_sdisable, help="disable a spell"})
phelper:add_cmd('senable', {func=cmd_senable, help="enable a spell"})
phelper:add_cmd('sba', {func=cmd_sablocker, help="add blockers, Ex. 'protection good:inertial barrier'"})
phelper:add_cmd('sbr', {func=cmd_sdblocker, help="remove blockers"})
phelper:add_cmd('pause', {func=cmd_pause, help="pause spellup"})
phelper:add_cmd('resume', {func=cmd_resume, help="resume spellup"})
phelper:add_cmd('refresh', {func=cmd_refresh, help="refresh affected spells"})
phelper:add_cmd('fast', {func=cmd_fast, help="cast all spells requested in one go"})
phelper:add_cmd('other', {func=cmd_other, help="cast spells on another char, use 'fast' to cast all spellup spells, otherwise it only casts the ones added with oadd"})
phelper:add_cmd('oadd', {func=cmd_oadd, help="add spells to cast on other"})
phelper:add_cmd('oremove', {func=cmd_oremove, help="remove spells to cast on other"})
phelper:add_cmd('odisable', {func=cmd_odisable, help="disable a spell"})
phelper:add_cmd('oenable', {func=cmd_oenable, help="enable a spell"})
phelper:add_cmd('olist', {func=cmd_olist, help="remove spells to cast on other"})
phelper:add_cmd('export', {func=cmd_export, help="export current spell list as list of commands"})
phelper:add_cmd('info', {func=cmd_info, help="show info on a spell"})
phelper:add_cmd('togglespellup', {func=cmd_togglespellup, help="toggle a spell to be a spellup regardless of what the mud says"})

phelper:enable()

--phelper:addaardhelps{"Map", "Automap", "Maprun", "Maptags", "Speedwalks", "Academy-Geography"}
--phelper:addaardcmds{"map", "automap", "maprun", "tags", "runto"}

]]>
</script>
</muclient>
