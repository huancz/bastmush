<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- $Id: miniwin_map.xml 917 2010-12-06 02:00:48Z endavis $ -->
<muclient>
<plugin
   name="bast_spellup"
   author="Bast"
   id="aaaf0c555a44169e0f1d9674"
   language="Lua"
   purpose="Bast's spellup plugin"
   date_written="2008-07-18"
   requires="4.52"
   version="6.0"
   save_state="y"
   >
<description trim="y">
bspell a all         --> cast all possible spellups
*bspell d all         --> remove all spellups

*bspell a blur  "champion's strength:3"    --> add more to the current list
  to add a spell in a certain place add a : then the place number
*bspell d "night vision" "detect magic"   --> remove those from the list

*bspell fast    --> cast all spellups immediately, as fast as you can
*bspell pause   --> stop casting spellups until a resume
*bspell resume  --> resume casting
*bspell refresh --> requery server for current spells on us

spellup other (name) --> try to spellup another player with picked spellups
                          (eg. spellup other johnsmith)

spellup other (name) all --> try to spellup another player with all spellups
                          (eg. spellup other johnsmith)

*bspell block   --> block a spell with another spell
                           (eg. bspell block 68 121)
*bspell disable --> disable a spell without taking it out of the list

*bspell help    --> this message

Bugs - Hide shows up as a negative spellup

TODO:
create miniwin based on mine
menu for each spell
 - show Help
 - showskill
 - Info
  - SN
  - stuff from slist
  
have tabs for:
 * Summary
   - how many good/bad/requested spells (can click good/bad/requested to go to good/bad/requested tab)
   - spells that are wearing off in less than one minute
   - recoveries
   - spells pending
   - disabled spells
 * Good
 * Bad
 * Requested
 * Other
   - show blocked
 * Combat - list both spells and skills that can be used in combat
 * Spellups - can click spells in this window to add them
    - columns for each - self, other
    - red can't add - (not practiced)
   
NOTES:
events that need to trigger a retry of spellups
* - spell wearoff
* - spell fail
* - spell success
* - stats change
* - position change
* - afk change
* - have slist
* - connect (and have slist)
* - recovery on
* - recovery off
* - resume
 - skillgain (?)
 
Spellup Other -
 put all at end (does all spellups)
 no all then does the ones you have picked from the spellups tab


</description>

</plugin>

<!--  Triggers  -->
<triggers>


</triggers>


<!--  Script  -->

<script>
<![CDATA[
internalrevision = "$Rev: 917 $"

dofile (GetPluginInfo (GetPluginID (), 20) .. "luapath.lua")

require 'var'
require 'pluginhelper'
require "tprint"
require "commas"
require "serialize"
require "ldplugin"
require "findfile"
require "verify"
require "aardutils"
require "bastspell"
require "stringfuncs"

nfile = scan_dir_for_file (GetInfo(60), "telnet_options.lua")

if nfile then
  -- pull in telnet option handling
  dofile (nfile)
else
  print("Could not load telnet_options.lua, please copy it to your plugin directory")
end

stats = nil

-- phelper.askedspells = list of tables with {sn, disabled, blocked}
askedspells_xref = nil
noneed = false

-- things that can block spells
have_slist = false
waiting = false
need_moves = false
need_mana = false
nocast = false

nocast_rooms = {}
current_room = -1

function getstatus()
  if phelper.pause then
    return "Paused"
  elseif need_mana then
    return "No mana"
  elseif need_moves then
    return "No moves"
  elseif nocast then
    return "Nocast room"
  else
    return capitalize(statestrings[tonumber(stats.status.state)])
  end
end

function getaskedspells()
  return serialize.save_simple(phelper.askedspells or "")
end

function event_askedspells_change()
  phelper:processevent('askedspells_change', phelper.askedspells)
end

function event_status_change()
  local status = getstatus()
  phelper:processevent('status_change', {status=status})
end

function isblocked(sn)
  if phelper.askedspells and askedspells_xref[sn] and phelper.askedspells[askedspells_xref[sn]].blockers then
    for blocker, _ in pairs(phelper.askedspells[askedspells_xref[sn]].blockers) do
      if spells['affected'][blocker] then
        return true
      end
    end
  end
  return false
end

function add_blocker(spell, blocker)
  local aspell = find_spell(spell)
  local sn = -1
  if aspell then
    sn = tonumber(aspell.sn)
  else
    print('Add Blocker: could not find spell', spell)
    return false
  end
  local bspell = find_spell(blocker)
  local blksn = -1
  if bspell then
    blksn = tonumber(bspell.sn)
  else
    print('could not find spell', blocker)
    return false
  end
  if sn and blksn and askedspells_xref[sn] and phelper.askedspells[askedspells_xref[sn]] then
    if phelper.askedspells[askedspells_xref[sn]] then
      if not phelper.askedspells[askedspells_xref[sn]].blockers then
        phelper.askedspells[askedspells_xref[sn]].blockers = {}
      end
      phelper.askedspells[askedspells_xref[sn]].blockers[blksn] = 1
      return true
    end
  end
  return false
end -- add_disabled

function remove_blocker(spell, blocker)
  local aspell = find_spell(spell)
  local sn = -1
  if aspell then
    sn = tonumber(aspell.sn)
  else
    print('Remove blocker: could not find spell', spell)
    return false
  end
  local bspell = find_spell(blocker)
  local blksn = -1
  if bspell then
    blksn = tonumber(bspell.sn)
  else
    print('could not find spell', blocker)
    return false
  end
  if sn and blksn and askedspells_xref[sn] and phelper.askedspells[askedspells_xref[sn]] then
    if phelper.askedspells[askedspells_xref[sn]] then
      phelper.askedspells[askedspells_xref[sn]].blockers[blksn] = nil
    end
    return true
  end
  return false
end

function cmd_refresh(cmddict)
  waiting= false
  noneed = false
  SendNoEcho("slist affected noprompt")
end

function make_askedspells_xrefs ()
  phelper:mdebug('making askedspells xref')
  askedspells_xref = {}
  for k, v in pairs (phelper.askedspells) do
    askedspells_xref[v.sn] = k
  end -- for each spell
  event_askedspells_change()  
end -- make_xrefs

function activatespell(sn, fast)
  fast = verify_bool(fast)
  if phelper.askedspells[askedspells_xref[sn]] then
    v = phelper.askedspells[askedspells_xref[sn]]
    if not spells['affected'][sn] then
      local cast = true
      local recov = spells['all'][sn].recovery
      if recov and recoveries['affected'][recov] then
        cast = false
      end
      if v.disabled or isblocked(sn) then
        cast = false
      end  
      if cast then
        if not fast then
          --print("setting waiting to", sn)
          waiting = tonumber(sn)
        end    
        if tonumber(spells['all'][sn]['type']) == 1 then
          SendNoEcho('cast ' .. tostring(sn))
        else
          words = justWords(spells['all'][sn].name)
          SendNoEcho(words[1])
        end
        return true
      end
    end
  end
  return false
end

function nextspellup (reason)
--  print("called nextspellup", reason, waiting)
  if have_slist and 
     stats ~= nil and 
     not waiting and 
     not need_mana and 
     not need_moves and 
     not noneed and
     not nocast and
     not phelper.pause and
     tonumber(stats.status.state) == 3 then
     
    --print('got to go through table')
    for k,v in ipairs(phelper.askedspells) do
      if activatespell(v.sn) then
        return
      end
    end
    noneed = true
    
  end
end

function formatheader()
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format("%-25s" , "Spell"),
             RGBColourToName(var.plugin_colour), "black", string.format("%-5s" , "SN"),
             RGBColourToName(var.plugin_colour), "black", string.format("%-10s", "Disabled"),
             RGBColourToName(var.plugin_colour), "black", string.format("%-10s", "Blocked By"))
 ColourNote(RGBColourToName(var.plugin_colour), "black",   "____________________________________________________")
end

function formatspell(name, sn, disabled, blocked)
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format("%-25s" , name),
             RGBColourToName(var.plugin_colour), "black", string.format("%-5s" , sn),
             RGBColourToName(var.plugin_colour), "black", string.format("%-10s", disabled),
             RGBColourToName(var.plugin_colour), "black", string.format("%-10s", blocked))
end

function cmd_listspells(cmddict)
  phelper:plugin_header("Spells requested (" .. tostring(#phelper.askedspells) .. ")")
  formatheader()
  for i,v in ipairs(phelper.askedspells) do
    local disabled = ""
    local blocked = ""
    local tstring = ""
    if v.disabled then
      disabled = "Yes"
    end
    if v.blockers then
      for sn,t in pairs(v.blockers) do
        blocked = blocked .. " " .. spells['all'][sn].name
      end
    end
    formatspell(spells['all'][v.sn].name, tonumber(v.sn), disabled, blocked)
  end
end

function cmd_pause(cmddict)
  phelper:plugin_header("Spellup Paused")
  --ColourNote(RGBColourToName(var.plugin_colour), "black", "Spellup Paused")
  phelper.pause = true
  event_status_change()  
end

function cmd_resume(cmddict)
  phelper:plugin_header("Spellup Resumed")
  --ColourNote(RGBColourToName(var.plugin_colour), "black", "Spellup Resumed")
  phelper.pause = false
  noneed = false
  event_status_change()  
  nextspellup("resumed")
end

function cmd_ablocker(cmddict)
  if #cmddict >= 1 then
    local ablocked = false
    phelper:plugin_header()    
    for i,item in ipairs(cmddict) do
      local place = nil
      colonplace, _ = string.find(item, ':')
      if colonplace and colonplace > 0 then
        tlist = utils.split(item, ':')
        sn = tlist[1]
        blck = tlist[2]
        local test = add_blocker(sn, blck)
        if test then
          ablocked = true
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " is now blocked by " .. spells['all'][tonumber(blck)].name)
        end
      end
    end
    if ablocked then
      event_askedspells_change()
    end
  end
  return true
end

function cmd_dblocker(cmddict)
  if #cmddict >= 1 then
    local rblocked = false
    phelper:plugin_header()    
    for i,item in ipairs(cmddict) do
      local place = nil
      colonplace, _ = string.find(item, ':')
      if colonplace and colonplace > 0 then
        tlist = utils.split(item, ':')
        sn = tlist[1]
        blck = tlist[2]
        if remove_blocker(sn, blck) then
          rblocked = true
        end
      end
    end
    if rblocked then
      event_askedspells_change()
    end    
  end
  return true
end


function cmd_disable(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()   
    local disabled = false
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        local sn = tonumber(aspell.sn)
        if sn then
          if askedspells_xref[sn] ~= nil then
            phelper.askedspells[askedspells_xref[sn]].disabled = true
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " disabled")    
            disabled = true
          else
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")      
          end
        end
      else
        print('Disable: could not find spell', item)
      end
    end
    if disabled then
      event_askedspells_change()
    end
  end
end

function cmd_enable(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()   
    local enabled = false
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        local sn = tonumber(aspell.sn)
        if sn then
          if askedspells_xref[sn] ~= nil then
            phelper.askedspells[askedspells_xref[sn]].disabled = false
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " enabled")          
            enabled = true
          else
            ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")      
          end
        end
      else
        print('Enable: could not find spell', item)      
      end
    end
    if enabled then
      noneed = false
      event_askedspells_change()      
      nextspellup("spells enabled")
    end
  end
end

function cmd_export(cmddict)
  local tdict = {}
  local tblock = {}
  for i,v in ipairs(phelper.askedspells) do
    table.insert(tdict, tostring(v.sn))
    if v.blockers then
      for f,u in pairs(v.blockers) do
        table.insert(tblock, tostring(v.sn) .. ':' .. tostring(f))
      end
    end
  end
  local tstring = phelper.cmd .. " delete all;"
  tstring = tstring .. phelper.cmd .. " add " .. table.concat(tdict, " ")
  if next(tblock) then
    local tblock = phelper.cmd .. " ablock " .. table.concat(tblock, " ")
    tstring = tstring .. ";" .. tblock
  end
  ColourNote(RGBColourToName(var.plugin_colour), "black", tstring)
end

function formatitem(row, data)
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format('%-20s: %s', tostring(row), tostring(data)))
end

function cmd_info(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header('Info')
    for i,item in ipairs(cmddict) do
      local aspell = find_spell(item)
      if aspell then
        --tprint(spells['all'][sn])
        formatitem("Name", aspell.name)
        formatitem("SN", aspell.sn)
        formatitem("Type", aspell.type)
        formatitem("Target", aspell.target)
        formatitem("Prac %", aspell.percent)
        if aspell.spellup then
          formatitem("Spellup", "Yes")
        end
        if aspell.recovery ~= -1 then
          formatitem("Recovery", recoveries['all'][aspell.recovery].name)
        end
        local tstring = "No"
        if askedspells_xref[aspell.sn] and phelper.askedspells[askedspells_xref[aspell.sn]] then
          tstring = "Yes"
          if phelper.askedspells[askedspells_xref[aspell.sn]].disabled then
            tstring = tstring .. " - Disabled"
          end
        end
        formatitem("Requested", tstring)
        ColourNote("black","black", "")
      else
        print('Info: could not find spell', item)
      end
    end
  end
end

function cmd_fast(cmddict)
  for i,v in ipairs(phelper.askedspells) do
    activatespell(tonumber(v.sn), true)
  end
end

function cmd_deletespell(cmddict)
  if #cmddict >= 1 then
    removed = false
    phelper:plugin_header()   
    if cmddict[1] == 'all' then
      phelper.askedspells = {}
      make_askedspells_xrefs()
      ColourNote(RGBColourToName(var.plugin_colour), "black", "All spells removed")
    else
      for i,item in ipairs(cmddict) do
        local aspell = find_spell(item)
        if aspell then
          local sn = tonumber(aspell.sn)
          if sn then
            if askedspells_xref[sn] ~= nil then
              table.remove(phelper.askedspells, askedspells_xref[sn])
              ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " removed")
              removed = true
            else
              ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " not in list")      
            end
          end
        else
          print('Delete Spell: could not find spell', item)
        end  
      end
      if removed then
        make_askedspells_xrefs()
      end
    end
  end
end

function cmd_addspell(cmddict)
  if #cmddict >= 1 then
    local added = false
    phelper:plugin_header()
    if cmddict[1] == 'all' then
      phelper.askedspells = {}    
      for i,v in pairs(spells['spellup']) do
        if v.percent > 1 then
          ColourNote(RGBColourToName(var.plugin_colour), "black", "Added " .. v.name)
          table.insert(phelper.askedspells, {sn=tonumber(i)})          
        end
      end
      ColourNote(RGBColourToName(var.plugin_colour), "black", "All spells added")
      make_askedspells_xrefs()
      nextspellup("added new spells")   
    else    
      for i,item in ipairs(cmddict) do
        local place = nil
        colonplace, _ = string.find(item, ':')
        if colonplace and colonplace > 0 then
          tlist = utils.split(item, ':')
          item = tlist[1]
          place = tlist[2]
        end
        local aspell = find_spell(item)
        if aspell then
          local sn = tonumber(aspell.sn)
          if sn then            
            if aspell.percent == 0 then
              ColourNote ("red", "", "You have not learnt '" .. aspell.name .. "'.")
              invalid = true
            elseif aspell.percent == 1 then
              ColourNote ("red", "", "You have not practiced '" .. aspell.name .. "'.")
              invalid = true
            elseif aspell.spellup ~= 1 then
              ColourNote ("red", "", "Spell '" .. aspell.name .. "' is not a spellup.")
              invalid = true
            else
              if askedspells_xref[tonumber(sn)] == nil then
                phelper:mdebug('adding ', item, sn, aspell.name, place)                
                local pos = -1
                if place then
                  table.insert(phelper.askedspells,place, {sn=tonumber(sn)})
                  pos = tostring(place)
                else
                  table.insert(phelper.askedspells, {sn=tonumber(sn)})
                  pos = tostring(#phelper.askedspells)
                end
                added = true
                ColourNote(RGBColourToName(var.plugin_colour), "black", "Added " .. aspell.name .. " in position " .. pos)
              else
                ColourNote(RGBColourToName(var.plugin_colour), "black", aspell.name .. " already in list")
              end
            end -- if
          else
            print('Add spell: could not find', item)
          end
        end
      end -- if number orname found
      if added then
        noneed = false
        make_askedspells_xrefs()
        nextspellup("added new spells")
      end
    end
  end
end

function formatspells()
  if not next(phelper.askedspells) then
    return "None"
  else
    local ttable = {}
    for i,v in ipairs(phelper.askedspells) do
      local tstring = v.sn
      if v.disabled then
        tstring = tstring .. " (disabled)"
      end
      table.insert(ttable, tstring)
    end
    return table.concat (ttable, ", ")
  end
end


]]>
</script>

<script>
<![CDATA[

--stats.vitals { "hp": 5280, "mana": 4390, "moves": 5185 }
--stats.stats { "str": 233, "int": 177, "wis": 213, "dex": 329, "con": 181, "luck": 245, "hr": 309, "dr": 371, "saves": 51 }
--stats.maxstats { "maxhp": 5280, "maxmana": 4390, "maxmoves": 5185, "maxstr": 110, "maxint": 100, "maxwis": 131, "maxdex": 182, "maxcon": 108, "maxluck": 157 }
--stats.worth { "gold": 322802, "bank": 0, "qp": 5257, "tp": 2, "trains": 1, "pracs": 3 }
--stats.status { "level": 180, "tnl": 1428, "hunger": 70, "thirst": 70, "align": 74, "state": 8, "pos": "Fighting" , "enemy": "a mountain cyclops", "enemypct": 12 }
--stats.base { "name": "Bast", "class": "Thief", "subclass": "Ninja", "race": "Shadow", "clan": "", "pretitle": "", "perlevel": 5000 }
function OnPluginBroadcast (msg, id, name, text)
  phelper:OnPluginBroadcast(msg, id, name, text)
  
  local old_mana = -1
  local old_moves = -1
  local old_state = -1
  if stats and stats.vitals then
    old_mana = tonumber(stats.vitals.mana)
    old_moves = tonumber(stats.vitals.moves)
  end
  if stats and stats.status then
    old_state = tonumber(stats.status.state)
  end
  if id == '3e7dedbe37e44942dd46d264' then
    if text:find("char") then
      res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char")
      local tt = assert (loadstring ('return ' .. gmcparg or ""))()
      if tt['vitals'] and tt['stats'] and tt['maxstats'] and tt['worth'] and tt['status'] and tt['base'] then
        stats = tt
        if tonumber(stats.vitals.mana) > old_mana then
          -- more mana
          need_mana = false
          event_status_change()           
          nextspellup('more mana')
        end
        if tonumber(stats.vitals.moves) > old_moves then
          -- more moves
          need_moves = false
          event_status_change()           
          nextspellup('more moves')
        end
        if tonumber(stats.status.state) == 3 and old_state ~= 3 then
          -- state changed to active from something else     
          nextspellup('state change to active')
        end
        if old_state ~= tonumber(stats.status.state) then
          event_status_change()        
        end
      end

    end
    if text:find("room.info") then
      res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
      local tt = assert (loadstring ('return ' .. gmcparg or ""))()
      current_room = tt.num
      if nocast_rooms[current_room] then
        phelper:mdebug('setting nocast true for', current_room, tt.name)
        nocast = true
        event_status_change()
      else
        if nocast then
          nocast = false
          event_status_change()
          nextspellup('left nocast room')
        end
      end      
    end
  end
  if id == 'aaa72f3b5453567e2bba9d50' then
    if msg == 5 then          
      -- spell casting failure    
      local tag = assert (loadstring ('return ' .. text or ""))()
      --tprint(tag)
      if tonumber(tag.sn) == waiting then
        waiting = false
      end
      if tag.reason == 1 then    
        if askedspells_xref[tonumber(tag.sn)] ~= nil then
          nextspellup('spell fail')            
        end
      elseif tag.reason == 2 then    
        if askedspells_xref[tonumber(tag.sn)] ~= nil then
          local tagsn = tonumber(tag.sn)
          phelper.askedspells[askedspells_xref[tagsn]].disabled = true
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tagsn].name .. " disabled because the affect already exists.")
          nextspellup('spell fail')            
        end 
      elseif tag.reason == 3 then
        nextspellup('spell fail')          
      elseif tag.reason == 4 then
        need_mana = true
        event_status_change()
      elseif tag.reason == 5 then
        nocast_rooms[current_room] = true
        nocast = true
        event_status_change()
      elseif tag.reason == 8 then
        -- remove from askedspells list
      elseif tag.reason == 11 then
        -- remove from askedspells list
      elseif tag.reason == 12 then
        need_moves = true
        event_status_change()        
      end
      
    elseif msg == 7 then          
      -- all spells  
      load_spells('all')
      if spells['all'] and recoveries['all'] then
        --print("have slist")
        have_slist = true
        nextspellup('have slist')
      end
      
    elseif msg == 8 then          
      -- learned spells
      load_spells('learned')
      
    elseif msg == 9 then          
      -- spellup spells
      load_spells('spellup')
      
    elseif msg == 10 then          
      -- affected spells
      --print('got affected')
      load_spells('affected')
      --tprint(spells['affected'])
      if waiting then
        if spells['affected'][waiting] then
          waiting = false
        end
      end
      if spells['all'] and recoveries['all'] then
        --print('have slist')
        have_slist = true
      end
      noneed=false
      nextspellup('spells affected change')
      
    elseif msg == 11 then          
      -- recoveries all
      load_recoveries('all')
      
    elseif msg == 12 then          
      -- recoveries affected
      --print('got recoveries')
      load_recoveries('affected')
      --tprint(recoveries['affected'])
      noneed=false
      if spells['all'] and recoveries['all'] then
        --print('have slist')
        have_slist = true
      end      
      nextspellup('recovery affected change')
      
    end  
    
  end
end

function OnPluginInstall ()
  --OnPluginEnable is automatically called by pluginhelper

  phelper:OnPluginInstall()
end -- OnPluginInstall

function OnPluginClose ()
  --OnPluginDisable is automatically called by pluginhelper

  phelper:OnPluginClose()
end -- OnPluginClose

function OnPluginEnable ()
  ldplugin ("aard_GMCP_handler", "3e7dedbe37e44942dd46d264")
  ldplugin ("broadcast_spellsskills", "aaa72f3b5453567e2bba9d50")

  phelper:OnPluginEnable()
  if IsConnected() then
    load_spells("all")
    --load_spells_xrefs()
    load_spells("affected")
    load_spells("spellup")
    --load_spells("learned")
    --print('loading recoveries in enable')
    load_recoveries("all")
    load_recoveries("affected")
    if spells['all'] and recoveries['all'] and recoveries['affected'] and spells['affected'] then
      --print("have slist")
      have_slist = true
      nextspellup('has slist')
    end
    CallPlugin("3e7dedbe37e44942dd46d264","Send_GMCP_Packet","request char")    
  end
  
  if askedspells_xref == nil then
    make_askedspells_xrefs ()
  end
end -- OnPluginEnable

function OnPluginDisable ()
  if GetPluginInfo(GetPluginID (), 17) and IsConnected() then
    --TelnetOptionOff (TELOPT_SPELLUP)
    --TelnetOptionOff (TELOPT_SKILLGAINS)
  end

  phelper:OnPluginDisable()
end -- OnPluginDisable

function OnPluginConnect ()
  TelnetOptionOn (TELOPT_SPELLUP)
  TelnetOptionOn (TELOPT_SKILLGAINS)

  phelper:OnPluginConnect()
end -- function OnPluginConnect

function OnPluginDisconnect ()

  phelper:OnPluginDisconnect()
end -- function OnPluginConnect

function OnPluginSaveState ()

  phelper:OnPluginSaveState()
end -- function OnPluginSaveState

]]>
</script>

<script>
<![CDATA[

phelper:set_default('cmd', 'bspell')
phelper:set_default('plugin_colour', 'lime')

phelper:add_setting( 'askedspells', {type="table", help="the list of spells", default=serialize.save_simple({}), sortlev=35, istable=true, formatfunc=formatspells, readonly=true, afterf=make_askedspells_xrefs})
phelper:add_setting( 'pause', {type="bool", help="pause spellup", default=false, sortlev=35, readonly=true})

phelper:add_cmd('listspells', {func=cmd_listspells, help="list request spells", default=true})
phelper:add_cmd('add', {func=cmd_addspell, help="add a spell"})
phelper:add_cmd('pause', {func=cmd_pause, help="pause spellup"})
phelper:add_cmd('resume', {func=cmd_resume, help="resume spellup"})
phelper:add_cmd('delete', {func=cmd_deletespell, help="remove a spell, use 'delete all' to clear table"})
phelper:add_cmd('disable', {func=cmd_disable, help="disable a spell"})
phelper:add_cmd('enable', {func=cmd_enable, help="enable a spell"})
phelper:add_cmd('ablock', {func=cmd_ablocker, help="add blockers, Ex. 'protection good:inertial barrier'"})
phelper:add_cmd('dblock', {func=cmd_dblocker, help="remove blockers"})
phelper:add_cmd('refresh', {func=cmd_refresh, help="refresh affected spells"})
phelper:add_cmd('fast', {func=cmd_fast, help="cast all spells in one go"})
phelper:add_cmd('other', {func=cmd_other, help="cast spells on another char"})
phelper:add_cmd('export', {func=cmd_export, help="export current spell list as list of commands"})
phelper:add_cmd('info', {func=cmd_info, help="show info on a spell"})

phelper:enable()

--phelper:addaardhelps{"Map", "Automap", "Maprun", "Maptags", "Speedwalks", "Academy-Geography"}
--phelper:addaardcmds{"map", "automap", "maprun", "tags", "runto"}

]]>
</script>
</muclient>
