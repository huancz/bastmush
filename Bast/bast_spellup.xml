<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- $Id: miniwin_map.xml 917 2010-12-06 02:00:48Z endavis $ -->
<muclient>
<plugin
   name="bast_spellup"
   author="Bast"
   id="aaaf0c555a44169e0f1d9674"
   language="Lua"
   purpose="Bast's spellup plugin"
   date_written="2008-07-18"
   requires="4.52"
   version="6.0"
   save_state="y"
   >
<description trim="y">
bspell a all         --> cast all possible spellups
*bspell d all         --> remove all spellups

*bspell a blur  "champion's strength:3"    --> add more to the current list
  to add a spell in a certain place add a : then the place number
*bspell d "night vision" "detect magic"   --> remove those from the list

*bspell fast    --> cast all spellups immediately, as fast as you can
*bspell pause   --> stop casting spellups until a resume
*bspell resume  --> resume casting
*bspell refresh --> requery server for current spells on us

spellup other (name) --> try to spellup another player with picked spellups
                          (eg. spellup other johnsmith)

spellup other (name) all --> try to spellup another player with all spellups
                          (eg. spellup other johnsmith)

*bspell block   --> block a spell with another spell
                           (eg. bspell block 68 121)
*bspell disable --> disable a spell without taking it out of the list

*bspell help    --> this message

Bugs - Hide shows up as a negative spellup

TODO:
create miniwin based on mine
menu for each spell
 - show Help
 - showskill
 - Info
  - SN
  - stuff from slist
  
have tabs for:
 * Summary
   - how many good/bad/requested spells (can click good/bad/requested to go to good/bad/requested tab)
   - spells that are wearing off in less than one minute
   - recoveries
   - spells pending
   - disabled spells
 * Good
 * Bad
 * Requested
 * Other
   - show blocked
 * Combat - list both spells and skills that can be used in combat
 * Spellups - can click spells in this window to add them
    - columns for each - self, other
    - red can't add - (not practiced)
   
NOTES:
events that need to trigger a retry of spellups
* - spell wearoff
* - spell fail
* - spell success
* - stats change
* - position change
* - afk change
* - have slist
* - connect (and have slist)
* - recovery on
* - recovery off
* - resume
 - skillgain (?)
 
Spellup Other -
 put all at end (does all spellups)
 no all then does the ones you have picked from the spellups tab


</description>

</plugin>

<!--  Triggers  -->
<triggers>


</triggers>


<!--  Script  -->

<script>
<![CDATA[
internalrevision = "$Rev: 917 $"

dofile (GetPluginInfo (GetPluginID (), 20) .. "luapath.lua")

require 'var'
require 'pluginhelper'
require "tprint"
require "commas"
require "serialize"
require "ldplugin"
require "findfile"
require "verify"
require "aardspellutils"
require "bastspell"

nfile = scan_dir_for_file (GetInfo(60), "telnet_options.lua")

if nfile then
  -- pull in telnet option handling
  dofile (nfile)
else
  print("Could not load telnet_options.lua, please copy it to your plugin directory")
end

stats = nil

-- phelper.askedspells = list of tables with {sn, disabled, blocked}
askedspells_xref = nil
noneed = false

-- things that can block spells
have_slist = false
waiting = false
need_moves = false
need_mana = false
nocast = false

nocast_rooms = {}
current_room = -1

function getaskedspells()
  return serialize.save_simple(phelper.askedspells or "")
end

function event_askedspells_change()
  phelper:processevent('askedspells_change', phelper.askedspells)
end

function isblocked(sn)
  if phelper.askedspells and askedspells_xref[sn] and phelper.askedspells[askedspells_xref[sn]].blockers then
    for blocker, _ in pairs(phelper.askedspells[askedspells_xref[sn]].blockers) do
      if spells['affected'][blocker] then
        return true
      end
    end
  end
  return false
end

function add_blocker(spell, blocker)
  sn, invalid = find_spellsn(spell)
  blksn, invalid = find_spellsn(blocker)
  if sn and blksn and askedspells_xref[sn] and phelper.askedspells[askedspells_xref[sn]] then
    if phelper.askedspells[askedspells_xref[sn]] then
      if not phelper.askedspells[askedspells_xref[sn]].blockers then
        phelper.askedspells[askedspells_xref[sn]].blockers = {}
      end
      phelper.askedspells[askedspells_xref[sn]].blockers[blksn] = 1
      return true
    end
  end
  return false
end -- add_disabled

function remove_blocker(spell, blocker)
  sn, invalid = find_spellsn(spell)
  blksn, invalid = find_spellsn(blocker)
  if sn and blksn and askedspells_xref[sn] and phelper.askedspells[askedspells_xref[sn]] then
    if phelper.askedspells[askedspells_xref[sn]] then
      phelper.askedspells[askedspells_xref[sn]].blockers[blksn] = nil
    end
    return true
  end
  return false
end

function cmd_refresh(cmddict)
  waiting= false
  noneed = false
  SendNoEcho("slist affected noprompt")
end

function make_askedspells_xrefs ()
  phelper:mdebug('making askedspells xref')
  askedspells_xref = {}
  for k, v in pairs (phelper.askedspells) do
    askedspells_xref [v.sn] = k
  end -- for each spell
  event_askedspells_change()  
end -- make_xrefs

function activatespell(sn, fast)
  fast = verify_bool(fast)
  if phelper.askedspells[askedspells_xref[sn]] then
    v = phelper.askedspells[askedspells_xref[sn]]
    if not spells['affected'][sn] then
      local cast = true
      local recov = spells['all'][sn].recovery
      if recov and recoveries['affected'][recov] then
        cast = false
      end
      if v.disabled or isblocked(sn) then
        cast = false
      end  
      if cast then
        if not fast then
          --print("setting waiting to", sn)
          waiting = tonumber(sn)
        end    
        if tonumber(spells['all'][sn].skilltype) == 1 then
          SendNoEcho('cast ' .. tostring(sn))
        else
          words = justWords(spells['all'][sn].name)
          SendNoEcho (words[1])
        end
        return true
      end
    end
  end
  return false
end

function nextspellup (reason)
  --print("called nextspellup", reason, waiting)
  if have_slist and 
     stats ~= nil and 
     not waiting and 
     not need_mana and 
     not need_moves and 
     not noneed and
     not nocast and
     not phelper.pause and
     tonumber(stats.status.state) == 3 then
     
    --print('got to go through table')
    for k,v in ipairs(phelper.askedspells) do
      if activatespell(v.sn) then
        return
      end
    end
    noneed = true
    
  end
end

function formatheader()
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format("%-25s" , "Spell"),
             RGBColourToName(var.plugin_colour), "black", string.format("%-5s" , "SN"),
             RGBColourToName(var.plugin_colour), "black", string.format("%-10s", "Disabled"),
             RGBColourToName(var.plugin_colour), "black", string.format("%-10s", "Blocked By"))
 ColourNote(RGBColourToName(var.plugin_colour), "black",   "____________________________________________________")
end

function formatspell(name, sn, disabled, blocked)
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format("%-25s" , name),
             RGBColourToName(var.plugin_colour), "black", string.format("%-5s" , sn),
             RGBColourToName(var.plugin_colour), "black", string.format("%-10s", disabled),
             RGBColourToName(var.plugin_colour), "black", string.format("%-10s", blocked))
end

function cmd_listspells(cmddict)
  phelper:plugin_header("Spells requested (" .. tostring(#phelper.askedspells) .. ")")
  formatheader()
  for i,v in ipairs(phelper.askedspells) do
    local disabled = ""
    local blocked = ""
    local tstring = ""
    if v.disabled then
      disabled = "Yes"
    end
    if v.blockers then
      for sn,t in pairs(v.blockers) do
        blocked = blocked .. " " .. spells['all'][sn].name
      end
    end
    formatspell(spells['all'][v.sn].name, tonumber(v.sn), disabled, blocked)
  end
end

function cmd_pause(cmddict)
  phelper:plugin_header("Spellup Paused")
  --ColourNote(RGBColourToName(var.plugin_colour), "black", "Spellup Paused")
  phelper.pause = true
end

function cmd_resume(cmddict)
  phelper:plugin_header("Spellup Resumed")
  --ColourNote(RGBColourToName(var.plugin_colour), "black", "Spellup Resumed")
  phelper.pause = false
  noneed = false
  nextspellup("resumed")
end

function cmd_ablocker(cmddict)
  if #cmddict >= 1 then
    local ablocked = false
    phelper:plugin_header()    
    for i,item in ipairs(cmddict) do
      local place = nil
      colonplace, _ = string.find(item, ':')
      if colonplace and colonplace > 0 then
        tlist = utils.split(item, ':')
        sn = tlist[1]
        blck = tlist[2]
        local test = add_blocker(sn, blck)
        if test then
          ablocked = true
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " is now blocked by " .. spells['all'][tonumber(blck)].name)
        end
      end
    end
    if ablocked then
      event_askedspells_change()
    end
  end
  return true
end

function cmd_dblocker(cmddict)
  if #cmddict >= 1 then
    local rblocked = false
    phelper:plugin_header()    
    for i,item in ipairs(cmddict) do
      local place = nil
      colonplace, _ = string.find(item, ':')
      if colonplace and colonplace > 0 then
        tlist = utils.split(item, ':')
        sn = tlist[1]
        blck = tlist[2]
        if remove_blocker(sn, blck) then
          rblocked = true
        end
      end
    end
    if rblocked then
      event_askedspells_change()
    end    
  end
  return true
end


function cmd_disable(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()   
    local disabled = false
    for i,item in ipairs(cmddict) do
      sn, invalid = find_spellsn(item)
      if sn then
        if askedspells_xref[sn] ~= nil then
          phelper.askedspells[askedspells_xref[sn]].disabled = true
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " disabled")    
          disabled = true
        else
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " not in list")      
        end
      end
    end
    if disabled then
      event_askedspells_change()
    end
  end
end

function cmd_enable(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header()   
    local enabled = false
    for i,item in ipairs(cmddict) do
      sn, invalid = find_spellsn(item)
      if sn then
        if askedspells_xref[sn] ~= nil then
          phelper.askedspells[askedspells_xref[sn]].disabled = false
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " enabled")          
          enabled = true
        else
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " not in list")      
        end
      end
    end
    if enabled then
      noneed = false
      event_askedspells_change()      
      nextspellup("spells enabled")
    end
  end
end

function cmd_export(cmddict)
  local tdict = {}
  local tblock = {}
  for i,v in ipairs(phelper.askedspells) do
    table.insert(tdict, tostring(v.sn))
    if v.blockers then
      for f,u in pairs(v.blockers) do
        table.insert(tblock, tostring(v.sn) .. ':' .. tostring(f))
      end
    end
  end
  local tstring = phelper.cmd .. " delete all;"
  tstring = tstring .. phelper.cmd .. " add " .. table.concat(tdict, " ")
  if next(tblock) then
    local tblock = phelper.cmd .. " ablock " .. table.concat(tblock, " ")
    tstring = tstring .. ";" .. tblock
  end
  ColourNote(RGBColourToName(var.plugin_colour), "black", tstring)
end

function formatitem(row, data)
  ColourNote(RGBColourToName(var.plugin_colour), "black", string.format('%-20s: %s', tostring(row), tostring(data)))
end

function cmd_info(cmddict)
  if #cmddict >= 1 then
    phelper:plugin_header('Info')
    for i,item in ipairs(cmddict) do
      sn, invalid = find_spellsn(item)  
      if sn then
        --tprint(spells['all'][sn])
        formatitem("Name", spells['all'][sn].name)
        formatitem("SN", sn)
        formatitem("Type", spelltype_table[spells['all'][sn].skilltype])
        formatitem("Target", spelltarget_table[spells['all'][sn].target])
        formatitem("Prac %", spells['all'][sn].percent)
        if spells['all'][sn].recovery ~= -1 then
          formatitem("Recovery", recoveries['all'][spells['all'][sn].recovery].name)
        end
        ColourNote("black","black", "")
      end
    end
  end
end

function cmd_fast(cmddict)
  for i,v in ipairs(phelper.askedspells) do
    activatespell(tonumber(v.sn), true)
  end
end

function cmd_deletespell(cmddict)
  if #cmddict >= 1 then
    removed = false
    phelper:plugin_header()   
    if cmddict[1] == 'all' then
      phelper.askedspells = {}
      make_askedspells_xrefs()
      ColourNote(RGBColourToName(var.plugin_colour), "black", "All spells removed")
    else
      for i,item in ipairs(cmddict) do
        sn, invalid = find_spellsn(item)
        if sn then
          if askedspells_xref[sn] ~= nil then
            table.remove(phelper.askedspells, askedspells_xref[sn])
            ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " removed")
            removed = true
          else
            ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " not in list")      
          end
          if removed then
            make_askedspells_xrefs()
          end
        end
      end
    end
  end
end

function cmd_addspell(cmddict)
  if #cmddict >= 1 then
    local added = false
    phelper:plugin_header()
    if cmddict[1] == 'all' then
      phelper.askedspells = {}    
      for i,v in pairs(spells['spellup']) do
        if v.percent > 1 then
          ColourNote(RGBColourToName(var.plugin_colour), "black", "Added " .. v.name)
          table.insert(phelper.askedspells, {sn=tonumber(i)})          
        end
      end
      ColourNote(RGBColourToName(var.plugin_colour), "black", "All spells added")
      make_askedspells_xrefs()
      nextspellup("added new spells")   
    else    
      for i,item in ipairs(cmddict) do
        local place = nil
        colonplace, _ = string.find(item, ':')
        if colonplace and colonplace > 0 then
          tlist = utils.split(item, ':')
          item = tlist[1]
          place = tlist[2]
        end
        sn, invalid = find_spellsn(item)  
        if sn then
          name = spells['all'] [sn].name
          if spells ['all'][sn].percent == 0 then
            ColourNote ("red", "", "You have not learnt '" .. name .. "'.")
            invalid = true
          elseif spells ['all'][sn].percent == 1 then
            ColourNote ("red", "", "You have not practiced '" .. name .. "'.")
            invalid = true
          elseif not spells ['spellup'][sn] then
            ColourNote ("red", "", "Spell '" .. name .. "' is not a spellup.")
            invalid = true
          else
            if askedspells_xref[tonumber(sn)] == nil then
              phelper:mdebug('adding ', item, sn, spells['all'][sn].name, invalid, place)                
              local pos = -1
              if place then
                table.insert(phelper.askedspells,place, {sn=tonumber(sn)})
                pos = tostring(place)
              else
                table.insert(phelper.askedspells, {sn=tonumber(sn)})
                pos = tostring(#phelper.askedspells)
              end
              added = true
              ColourNote(RGBColourToName(var.plugin_colour), "black", "Added " .. spells['all'][tonumber(sn)].name .. " in position " .. pos)
            else
              ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tonumber(sn)].name .. " already in list")
            end
          end -- if
        end
        if added then
          noneed = false
          make_askedspells_xrefs()
          nextspellup("added new spells")
        end
      end -- if number orname found
    end
  end
end

function formatspells()
  if not next(phelper.askedspells) then
    return "None"
  else
    local ttable = {}
    for i,v in ipairs(phelper.askedspells) do
      local tstring = v.sn
      if v.disabled then
        tstring = tstring .. " (disabled)"
      end
      table.insert(ttable, tstring)
    end
    return table.concat (ttable, ", ")
  end
end


]]>
</script>

<script>
<![CDATA[

--stats.vitals { "hp": 5280, "mana": 4390, "moves": 5185 }
--stats.stats { "str": 233, "int": 177, "wis": 213, "dex": 329, "con": 181, "luck": 245, "hr": 309, "dr": 371, "saves": 51 }
--stats.maxstats { "maxhp": 5280, "maxmana": 4390, "maxmoves": 5185, "maxstr": 110, "maxint": 100, "maxwis": 131, "maxdex": 182, "maxcon": 108, "maxluck": 157 }
--stats.worth { "gold": 322802, "bank": 0, "qp": 5257, "tp": 2, "trains": 1, "pracs": 3 }
--stats.status { "level": 180, "tnl": 1428, "hunger": 70, "thirst": 70, "align": 74, "state": 8, "pos": "Fighting" , "enemy": "a mountain cyclops", "enemypct": 12 }
--stats.base { "name": "Bast", "class": "Thief", "subclass": "Ninja", "race": "Shadow", "clan": "", "pretitle": "", "perlevel": 5000 }
function OnPluginBroadcast (msg, id, name, text)
  phelper:OnPluginBroadcast(msg, id, name, text)
  
  local old_mana = -1
  local old_moves = -1
  local old_state = -1
  if stats and stats.vitals then
    old_mana = tonumber(stats.vitals.mana)
    old_moves = tonumber(stats.vitals.moves)
  end
  if stats and stats.status then
    old_state = tonumber(stats.status.state)
  end
  if id == '3e7dedbe37e44942dd46d264' then
    if text:find("char") then
      res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char")
      local tt = assert (loadstring ('return ' .. gmcparg or ""))()
      if tt['vitals'] and tt['stats'] and tt['maxstats'] and tt['worth'] and tt['status'] and tt['base'] then
        stats = tt
        if tonumber(stats.vitals.mana) > old_mana then
          -- more mana
          need_mana = false
          nextspellup('more mana')
        end
        if tonumber(stats.vitals.moves) > old_moves then
          -- more moves
          need_moves = false
          nextspellup('more moves')
        end
        if tonumber(stats.status.state) == 3 and old_state ~= 3 then
          -- state changed to active from something else
          nextspellup('state change to active')
        end
      end

    end
    if text:find("room.info") then
      res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
      local tt = assert (loadstring ('return ' .. gmcparg or ""))()
      current_room = tt.num
      if nocast_rooms[current_room] then
        phelper:mdebug('setting nocast true for', current_room, tt.name)
        nocast = true
      else
        if nocast then
          nocast = false
          nextspellup('left nocast room')
        end
      end      
    end
  end
  if id == 'aaa72f3b5453567e2bba9d50' then
    if msg == 5 then          
      -- spell casting failure    
      local tag = assert (loadstring ('return ' .. text or ""))()
      --tprint(tag)
      if tonumber(tag.sn) == waiting then
        waiting = false
      end
      if tag.reason == 1 then    
        if askedspells_xref[tonumber(tag.sn)] ~= nil then
          nextspellup('spell fail')            
        end
      elseif tag.reason == 2 then    
        if askedspells_xref[tonumber(tag.sn)] ~= nil then
          local tagsn = tonumber(tag.sn)
          phelper.askedspells[askedspells_xref[tagsn]].disabled = true
          ColourNote(RGBColourToName(var.plugin_colour), "black", spells['all'][tagsn].name .. " disabled because the affect already exists.")
          nextspellup('spell fail')            
        end 
      elseif tag.reason == 3 then
        nextspellup('spell fail')          
      elseif tag.reason == 4 then
        need_mana = true
      elseif tag.reason == 5 then
        nocast_rooms[current_room] = true
        nocast = true
      elseif tag.reason == 8 then
        -- remove from askedspells list
      elseif tag.reason == 11 then
        -- remove from askedspells list
      elseif tag.reason == 12 then
        need_moves = true
      end
    elseif msg == 7 then          
      -- slist all    
      spells['all'] = assert (loadstring ('return ' .. text or ""))()
      load_spells_xrefs()      
      if spells['all'] and spells['affected'] and recoveries['affected'] then
        --print("have slist")
        have_slist = true
        nextspellup('have slist')
      end
      
    elseif msg == 8 then          
      -- slist learned
      spells['learned'] = assert (loadstring ('return ' .. text or ""))()
      
    elseif msg == 9 then          
      -- slist spellups
      spells['spellup'] = assert (loadstring ('return ' .. text or ""))()

    elseif msg == 10 then          
      -- slist affected
      spells['affected'] = assert (loadstring ('return ' .. text or ""))()
      if waiting then
        if spells['affected'][waiting] then
          waiting = false
        end
      end
      if spells['all'] and spells['affected'] and recoveries['affected'] then
        --print('have slist')
        have_slist = true
      end
      noneed=false
      nextspellup('spells affected change')
    elseif msg == 11 then          
      -- recoveries all
      recoveries['all'] = assert (loadstring ('return ' .. text or ""))()

    elseif msg == 12 then          
      -- recoveries affected
      recoveries['affected'] = assert (loadstring ('return ' .. text or ""))()
      noneed=false
      if spells['all'] and spells['affected'] and recoveries['affected'] then
        --print('have slist')
        have_slist = true
      end      
      nextspellup('recovery affected change')
    end  
    
  end
end

function OnPluginInstall ()
  --OnPluginEnable is automatically called by pluginhelper

  phelper:OnPluginInstall()
end -- OnPluginInstall

function OnPluginClose ()
  --OnPluginDisable is automatically called by pluginhelper

  phelper:OnPluginClose()
end -- OnPluginClose

function OnPluginEnable ()
  ldplugin ("aard_GMCP_handler", "3e7dedbe37e44942dd46d264")
  ldplugin ("broadcast_spellsskills", "aaa72f3b5453567e2bba9d50")

  phelper:OnPluginEnable()
  if IsConnected() then
    load_spells("all")
    load_spells_xrefs()
    load_spells("affected")
    load_spells("spellup")
    load_spells("learned")
    load_recoveries("all")
    load_recoveries("affected")
    if spells['all'] and spells['affected'] and recoveries['affected'] then
      --print("have slist")
      have_slist = true
    end
    CallPlugin("3e7dedbe37e44942dd46d264","Send_GMCP_Packet","request char")    
  end
  
  if askedspells_xref == nil then
    make_askedspells_xrefs ()
  end
end -- OnPluginEnable

function OnPluginDisable ()
  if GetPluginInfo(GetPluginID (), 17) and IsConnected() then
    --TelnetOptionOff (TELOPT_SPELLUP)
    --TelnetOptionOff (TELOPT_SKILLGAINS)
  end

  phelper:OnPluginDisable()
end -- OnPluginDisable

function OnPluginConnect ()
  TelnetOptionOn (TELOPT_SPELLUP)
  TelnetOptionOn (TELOPT_SKILLGAINS)

  phelper:OnPluginConnect()
end -- function OnPluginConnect

function OnPluginDisconnect ()

  phelper:OnPluginDisconnect()
end -- function OnPluginConnect

function OnPluginSaveState ()

  phelper:OnPluginSaveState()
end -- function OnPluginSaveState

]]>
</script>

<script>
<![CDATA[

phelper:set_default('cmd', 'bspell')
phelper:set_default('plugin_colour', 'lime')

phelper:add_setting( 'askedspells', {type="table", help="the list of spells", default=serialize.save_simple({}), sortlev=35, istable=true, formatfunc=formatspells, readonly=true, afterf=make_askedspells_xrefs})
phelper:add_setting( 'pause', {type="bool", help="pause spellup", default=false, sortlev=35, readonly=true})

phelper:add_cmd('listspells', {func=cmd_listspells, help="list request spells", default=true})
phelper:add_cmd('add', {func=cmd_addspell, help="add a spell"})
phelper:add_cmd('pause', {func=cmd_pause, help="pause spellup"})
phelper:add_cmd('resume', {func=cmd_resume, help="resume spellup"})
phelper:add_cmd('delete', {func=cmd_deletespell, help="remove a spell, use 'delete all' to clear table"})
phelper:add_cmd('disable', {func=cmd_disable, help="disable a spell"})
phelper:add_cmd('enable', {func=cmd_enable, help="enable a spell"})
phelper:add_cmd('ablock', {func=cmd_ablocker, help="add blockers, Ex. 'protection good:inertial barrier'"})
phelper:add_cmd('dblock', {func=cmd_dblocker, help="remove blockers"})
phelper:add_cmd('refresh', {func=cmd_refresh, help="refresh affected spells"})
phelper:add_cmd('fast', {func=cmd_fast, help="cast all spells in one go"})
phelper:add_cmd('other', {func=cmd_other, help="cast spells on another char"})
phelper:add_cmd('export', {func=cmd_export, help="export current spell list as list of commands"})
phelper:add_cmd('info', {func=cmd_info, help="show info on a spell"})

phelper:enable()

--phelper:addaardhelps{"Map", "Automap", "Maprun", "Maptags", "Speedwalks", "Academy-Geography"}
--phelper:addaardcmds{"map", "automap", "maprun", "tags", "runto"}

]]>
</script>
</muclient>
