<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- $Id$ -->
<muclient>
<plugin
   name="xeqDB"
   author="Bast"
   id="aaa56faed92ffc6146964abc"
   language="Lua"
   purpose="add eq to a database"
   save_state="y"
   date_written="2009-02-22 14:20:07"
   requires="4.73"
   version="6.1"
   >

<description trim="y">
<![CDATA[
[FOR PLUGIN AUTHORS ONLY]

#TODO: container changes when getting/removing
#TODO: add designation to containers such as 'special', 'portal', 'potion'

]]>
</description>
</plugin>

<!--  Get our standard constants -->

<include name="constants.lua"/>


<triggers>

 <trigger
   enabled="y"
   match="^Syntax: invdata                - view all inv data.$"
   omit_from_output="n"
   name="badinvdata1"
   sequence="100"
   regexp="y"
  >
  </trigger>

   <trigger
   enabled="y"
   match="^      : invdata <container id> - view all inv data in a container.$"
   omit_from_output="n"
   name="badinvdata2"
   sequence="100"
   regexp="y"
  >
  </trigger>

   <trigger
   enabled="y"
   match="^      : invdata ansi           - remove color codes from output.$"
   omit_from_output="n"
   name="badinvdata3"
   sequence="100"
   regexp="y"
  >
  </trigger>

  <trigger
   enabled="y"
   match="^{invmon}(?&lt;action&gt;.*),(?&lt;serial&gt;.*),(?&lt;container&gt;.*),(?&lt;location&gt;.*)$"
   name="invmon"
   script="invmon"
   sequence="100"
   regexp="y"
   omit_from_output="n"
  >
  </trigger>

 <trigger
   enabled="y"
   match="^{eqdata}$"
   script="eqdata_redirect"
   omit_from_output="n"
   name="start_eqdata"
   sequence="100"
   regexp="y"
  >
  </trigger>

  <trigger
   enabled="n"
   match="*"
   script="eqdata_redirect"
   name="multi_line_eqdata"
   omit_from_output="n"
   group="eqdata"
   sequence="10"
  >
  </trigger>

  <trigger
   enabled="y"
   match="^\{invitem\}(.*)$"
   name="invitem"
   script="invitem"
   sequence="100"
   regexp="y"
   omit_from_output="n"
  >
  </trigger>

 <trigger
   enabled="y"
   match="^{invdata\s*(?&lt;container&gt;.*)}$"
   script="invdata_redirect"
   omit_from_output="n"
   name="start_invdata"
   sequence="100"
   regexp="y"
  >
  </trigger>

  <trigger
   enabled="n"
   match="*"
   script="invdata_redirect"
   name="multi_line_invdata"
   omit_from_output="n"
   group="invdata"
   sequence="10"
  >
  </trigger>
  <trigger
   enabled="n"
   regexp="y"
   match="^$"
   script="emptyline"
   name="emptyline"
   omit_from_output="n"
   group="emptyline"
   sequence="10"
  >
  </trigger>
 <trigger
   enabled="y"
   match="^{invdetails}$"
   script="invdetails_redirect"
   omit_from_output="n"
   name="start_invdetails"
   sequence="100"
   regexp="y"
  >
  </trigger>

  <trigger
   enabled="n"
   match="*"
   script="invdetails_redirect"
   name="multi_line_invdetails"
   omit_from_output="n"
   group="invdetails"
   sequence="10"
  >
  </trigger>
</triggers>

<timers>
  <timer
      script="dbbackup"
      enabled="y"
      hour="13"
      name="backuptimeronepm"
      at_time="y"
      >
  </timer>
  <timer
      script="dbbackup"
      enabled="y"
      hour="1"
      name="backuptimermidoneam"
      at_time="y"
      >
  </timer>
</timers>

<aliases>

</aliases>


<script>
<![CDATA[
internalrevision = "$Rev$"

dofile (GetPluginInfo (GetPluginID (), 20) .. "luapath.lua")

require "var"
require "serialize"
require "commas"
require "pluginhelper"
require "verify"
require "aardutils"
require "chardb"
require 'colours'
require "eqdb"

db = EQdb:new{}

P, V, Cg, Ct, Cc, S, R, C, Cf, Cb = lpeg.P, lpeg.V, lpeg.Cg, lpeg.Ct, lpeg.Cc, lpeg.S, lpeg.R, lpeg.C, lpeg.Cf, lpeg.Cb

wearpeg = (P("wea") * -P(1)) + (P("wear") * -P(1))
getpeg = (P("g") * -P(1)) + (P("ge") * -P(1)) + (P("get") * -P(1))
putpeg = (P("pu") * -P(1)) + (P("put") * -P(1))
lookpeg = (P("l") * -P(1)) + (P("lo") * -P(1)) + (P("loo") * -P(1)) + (P("look") * -P(1))
removepeg = (P("re") * -P(1)) + (P("rem") * -P(1)) + (P("remo") * -P(1)) + (P("remov") * -P(1)) + (P("remove") * -P(1))
alldotpeg = P("all") * P(".") * P(1)^1
inpeg = (P("i") * -P(1)) + (P("in") * -P(1))

eqdata = {}
invdata = {}
waiting = {}
container = ""
place = 0
initdb = false
wearingall = false
removingall = false
puttingall = false
gettingall = false
silent = true

allcontainer = -1

layout ={
invheader = {"serial", "level", "type", "worth", "weight", "wearable", "flags", "owner", "fromclan", "timer", "u1", "u2", "u3", "score"},
container = {"capacity", "heaviestitem", "holding", "itemsinside", "totalweight", "itemburden", "itemweightpercent"},
statmod = {"stat", "value"},
resistmod = {"resist", "value"},
weapon = {"wtype", "avedam", "inflicts", "damtype", "special"},
skillmod = {"skillnum", "value"},
spells = {"uses", "level", "sn1", "sn2", "sn3", "sn4", "u1"},
food = {"percent"},
drink = {"servings", "liquid", "liquidmax", "liquidleft", "thirstpercent", "hungerpercent", "u1"},
furniture = {"hpregen","manaregen","u1"},
eqdata = {"serial", "shortflags", "name", "level", "type", "unique", "wearslot", "timer"}
}

function dbbackup(name)
  local day = os.date("%a", GetInfo(304))
  if name == "backuptimeronepm" then
    db:backupdb(day .. '.onepm')
  elseif name == "backuptimeroneam" then
    db:backupdb(day .. '.oneam')
  else
    db:backupdb(day)
  end
end

function sendcmd(cmd)
  if silent then
    SendNoEcho(cmd)
  else
    Send(cmd)
  end
end

function showoutput(stuff)
  if phelper.showoutput then
    print(stuff)
  end
end

function getdata(type)
  if waiting[type] then
    return
  end
  if type == 'Inventory' then
    sendcmd('invdata')
  elseif type == 'Worn' then
    sendcmd('eqdata')
  else
    sendcmd('invdata ' .. tostring(type))
  end
  waiting[type] = true
end

function addmod(ltype, mod)
  if invdetails[ltype] == nil then
    invdetails[ltype] = {}
  end
  invdetails[ltype][mod[1]] = tonumber(mod[2])
end

function event_container_change(containerid)
  timer_start('event_container_change')
  phelper:processevent('container_change', containerid)
  if containerid ~= 'Worn' and containerid ~= 'Inventory' then
    titem = db:getitemdetails(containerid)
    if titem and next(titem) then
      phelper:processevent('itemchange', titem)
    end
  end
  timer_end('event_container_change')
end

function event_wearloc_change(wearloc,action)
  timer_start('event_wearloc_change')
  phelper:processevent('wearlocchange', {wearloc=wearloc,action=action})
  timer_end('event_wearloc_change')
end

function dataparse(line, layoutname)
  local tlist = utils.split(line, ',')
  local wearloc = tlist[7]
  local titem = {}
  for i,v in ipairs(layout[layoutname]) do
    local value = tlist[i]
    if v == 'wearloc' or v == 'itemtype' or v == 'level' then
      value = tonumber(value)
    end
    titem[v] = value
  end
  return titem
end

function eqdata_redirect (name, line, wildcards, styles)
  -- start of spells list? remove old ones
  if name == "start_eqdata" then
    eqdata = {}
    container = 'Worn'
    phelper:enabletriggroup("eqdata", true)
    return
  elseif line == "{/eqdata}" then
    phelper:enabletriggroup("eqdata", false)
    db:clearcontainer(container)
    db:additems(eqdata)
    --db:addcontainer('worn', eqdata)
    event_container_change('Worn')
    waiting['Worn'] = nil
    return
  end -- if

  if line ~= "" then
    titem = dataparse(line, 'eqdata')
    titem.containerid = container
    titem.place = -2
    titem.plainname = strip_colours(titem.name)
    eqdata[titem.serial] = titem
  end

end

function invdata_redirect (name, line, wildcards, styles)
  -- start of spells list? remove old ones
  if name == "start_invdata" then
    place = 0
    invdata = {}
    if wildcards.container ~= "" then
      container = trim(wildcards.container)
    else
      container = 'Inventory'
    end
    phelper:enabletriggroup("invdata", true)
    return
  elseif line == "{/invdata}" then
    phelper:enabletriggroup("invdata", false)
    db:clearcontainer(container)
    db:additems(invdata)
    --db:addcontainer(container, invdata)
    waiting[container] = nil
    event_container_change(container)
    if initdb then
      initdb = false
      getcontainers()
    end
    return
  end -- if

  place = place + 1
  titem = dataparse(line, 'eqdata')
  titem.containerid = container
  titem.plainname = strip_colours(titem.name)
  titem.place = place
  invdata[titem.serial] = titem
end

function invdetails_redirect (name, line, wildcards, styles)
  -- start of spells list? remove old ones
  ltype = 'unknown'
  if name == "start_invdetails" then
    invdetails = {}
    timer_start('invdetails')
    phelper:enabletriggroup("invdetails", true)
    return
  elseif line == "{/invdetails}" then
    phelper:enabletriggroup("invdetails", false)
    local titem = db:getitem(invdetails.serial)
    invdetails.name = titem.name
    invdetails.plainname = titem.plainname
    invdetails.containerid = titem.containerid
    invdetails.type = titem.type
    timer_end('invdetails')
    db:additemdetail(invdetails)
    phelper:processevent('itemchange', invdetails)
    return
  end -- if

  ttype = string.match(line,"{(.*)}")
  if layout[ttype] then
    ltype = ttype
  else
    print('no layout for', ttype)
  end

  local tlist = utils.split(line, '}')
  local llist = utils.split(tlist[2], '|')
  if layout[ltype] then
    if ltype == "statmod" or ltype == "resistmod" or ltype == "skillmod" then
      addmod(ltype, llist)
    else
      for i,v in ipairs(layout[ltype]) do
        if ltype == 'invheader' then
          local value = llist[i]
          if v == 'itemtype' or v == 'level' then
            value = tonumber(value)
          end
          invdetails[v] = value
        else
          if invdetails[ltype] == nil then
            invdetails[ltype] = {}
          end
          local value = llist[i]
          if v == 'wearloc' or v == 'itemtype' or v == 'level' then
            value = tonumber(value)
          end
          invdetails[ltype][v] = value
        end
      end
    end
  end
end

function builditem(wildcards)
  local item = {}
  item.placestr = wearlocs[tonumber(wildcards.location) + 1] or -1
  item.wearslot = wildcards.location
  item.serial = wildcards.serial
  item.containerid = wildcards.container
  return item
end

function invmon ( name, line, wildcards )
  phelper:mdebug(line)
  item = builditem(wildcards)
  checkaction(tonumber(wildcards.action), item)
end

function invitem( name, line, wildcards)
  local rline = wildcards[1]
  local tstuff = dataparse(rline, 'eqdata')
  olditem = db:getitem(tstuff.serial)
  if olditem then
    for i,v in pairs(layout['eqdata']) do
      if v ~= 'name' then
        olditem[v] = tstuff[v]
      end
    end
    db:updateitem(olditem)
  end
  event_container_change('Inventory')
end

function emptyline()
  phelper:enabletriggroup("emptyline", false)
  --print('removingall =', removingall)
  --print('wearingall =', wearingall)
  getdata('Inventory')
  if removingall or wearingall then
    getdata('Worn')
    showoutput('setting removingall and wearingall to false')
    removingall = false
    wearingall = false
    event_wearloc_change('All')
  end
  if gettingall or puttingall then
    if allcontainer ~= -1 then
      db:clearcontainer(allcontainer)
      getdata(allcontainer)
      showoutput('setting gettingall and puttingall = false')
      gettingall = false
      puttingall = false
      allcontainer = -1
    end
  end
end

function initinv(char)
  if char.status and char.status.state and tonumber(char.status.state) == 3 and db:checkfortable('items') == false then
    getdata('Worn')
    getdata('Inventory')
    initdb = true
  end
end

function getcontainers()
 for i,v in pairs(invdata) do
   if tonumber(v.type) == 11 then
     getdata(v.serial)
   end
 end
end

function getitemdetails(id)
  --print('getitemdetails', type(id), id)
  local titem = db:getitemdetails(id)
  if titem then
    phelper:processevent('itemchange', titem)
  else
    local titem2 = db:getitem(id)
    if titem2 then
      if titem2.containerid == 'Inventory' or titem2.containerid == 'Worn' then
        sendcmd('invdetails ' .. tostring(id))
      else
        putobjectininv(titem2)
        sendcmd('invdetails ' .. tostring(id))
        putobjectincontainer(titem2, titem2.containerid)
      end
    end
  end
end

function cmd_refresh(cmddict)
  if db:open('cmd_refresh') then
    db:close('cmd_refresh', true)
    db:open('cmd_refresh')
    local returnval = db.db:exec([[DROP TABLE IF EXISTS items;]])
    --print('exec returned: ', returnval)
    db:close('cmd_refresh', true)
    local res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char")
    local char = assert (loadstring ('return ' .. gmcparg or ""))()
    initinv(char)
  end
end

function cmd_clean(cmddict)
  db:cleandb()
end

function cmd_close(cmddict)
  db:close('cmd_close', true)
end

function cmd_addid(cmddict)
  if cmddict[1] and cmddict[2] then
    local titem = db:getitem(cmddict[1])
    if titem then
      local changes = db:addidentifier(titem.serial, cmddict[2])
      if changes > 0 then
        ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Identifier " .. cmddict[2] .. " was added to " .. cmddict[1])
      else

      end
    else
      phelper:plugin_header('Add Identifier')
      ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Item " .. cmddict[1] .. " does not exist!")
    end
  end
end

function cmd_remid(cmddict)
  if cmddict[1] then
    for i,v in ipairs(cmddict) do
      local tchange = db:removeidentifier(v)
      if tchange == 1 then
        ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Identifier " .. v .. " was removed")
      else
        ColourNote("red", "black", "Identifier " .. v .. " was not found")
      end
    end
  end
end

function print_id(item)
  local ids = strjoin(", ", item.identifier)
  ColourNote("green", "black", string.format('%-15d %-30s %s', item.serial, ids, item.plainname))
end

function cmd_listid(cmddict)
  local idents = db:getidentifiers()
  ColourNote("green", "black", string.format('%-15s %-30s %s', 'Serial', 'Identifiers', 'Name'))
  ColourNote("green", "black", string.rep('-', 70))
  for i,v in pairs(idents) do
    print_id(v)
  end
  ColourNote("", "", "")
end

function checkaction(action, item, afterwait)
  if action == 1 and removingall == false then
    timer_start('EQdb:action1')
    -- item removed
    --print('action 1')
    local oldwearslot = item.wearslot
    item.containerid = 'Inventory'
    item.wearslot = -1
    item.place = 1
    local reorder = {}
    reorder['Inventory'] = {place=1, containerid='Inventory', removed=false}
    db:reorderitemsmultiple(reorder)
    db:updateitemlocation(item)
    event_container_change('Inventory')
    event_container_change('Worn')
    event_wearloc_change(oldwearslot, 1)
    timer_end('EQdb:action1')
  elseif action == 1 and removingall then
     db:clearcontainer('Worn')
     phelper:enabletriggroup("emptyline", true)
  elseif action == 2 and wearingall == false then
    timer_start('EQdb:action2')
    -- item worn
    --print('action 2')
    item.containerid = 'Worn'
    olditem = db:getitem(item.serial)
    item.place = -2
    local reorder = {}
    if olditem then
      reorder['Inventory'] = {place=olditem.place, containerid='Inventory', removed=true}
      db:reorderitemsmultiple(reorder)
      db:updateitemlocation(item)
      event_container_change('Inventory')
      event_container_change('Worn')
    else
      showoutput('action 2 setting removeall true')
      removingall = true
      phelper:enabletriggroup("emptyline", true)
    end
    event_wearloc_change(item.wearslot, 2)
    timer_end('EQdb:action2')
  elseif action == 2 and wearingall then
   phelper:enabletriggroup("emptyline", true)
  elseif action == 3 then
    -- dropped, sold
    --print('action 3')
    phelper:enabletriggroup("emptyline", true)
  elseif action == 4 then
    -- added (received, picked up)
    --print('action 4')
    phelper:enabletriggroup("emptyline", true)
    --db:additems({item})
  elseif action == 5 and gettingall == false then
    timer_start('EQdb:action5')
    -- removed from container
    --print('action 5')
    olditem = db:getitem(item.serial)
    item.containerid = 'Inventory'
    item.place = 1
    local reorder = {}
    if olditem then
      reorder[olditem.containerid] = {place=olditem.place, containerid=olditem.containerid, removed=true}
    end
    reorder['Inventory'] = {place=1, containerid='Inventory', removed=false}
    db:reorderitemsmultiple(reorder)
    db:updateitemlocation(item)
    event_container_change('Inventory')
    if olditem then
      event_container_change(olditem.containerid)
    end
    timer_end('EQdb:action5')
  elseif action == 5 and gettingall == true then
    db:clearcontainer('Inventory')
    showoutput('action: 5, gettingall: ' .. tostring(gettingall))
    allcontainer = item.containerid
    phelper:enabletriggroup("emptyline", true)
  elseif action == 6 and puttingall == false then
    timer_start('EQdb:action6')
    -- put into container
    --print('action 6')
    olditem = db:getitem(item.serial)
    item.place = 1
    local reorder = {}
    if olditem then
      reorder['Inventory'] = {place=olditem.place, containerid='Inventory', removed=true}
    end
    reorder[item.containerid] = {place=1, containerid=item.containerid, removed=false}
    db:reorderitemsmultiple(reorder)
    db:updateitemlocation(item)
    event_container_change('Inventory')
    event_container_change(item.containerid)
    timer_end('EQdb:action6')
  elseif action == 6 and puttingall == true then
    db:clearcontainer('Inventory')
    showoutput('action: 6, puttingall: ' ..  tostring(puttingall))
    allcontainer = item.containerid
    phelper:enabletriggroup("emptyline", true)
  elseif action == 7 then
    -- consumed
    --print('action 7')
    db:removeitems({item})
    event_container_change('Inventory')
  end
end

function toggleoutput(tflag)
  local trigstoupdate = {"invmon", "invitem", "start_invdetails", "multi_line_invdetails", "start_eqdata",
                    "multi_line_eqdata" , "start_invdata", "multi_line_invdata", "badinvdata1",
                    "badinvdata2", "badinvdata3"}
  for i,v in ipairs(trigstoupdate) do
    if tflag then
      SetTriggerOption(v, "omit_from_output", "n");
      silent = false
    else
      SetTriggerOption(v, "omit_from_output", "y");
      silent = true
    end
  end
end

function afterdebug()
  toggleoutput(phelper.tdebug)
end

function aftershowset()
  toggleoutput(phelper.showoutput)
end
]]>
</script>

<script>
<![CDATA[

function OnPluginBroadcast (msg, id, name, text)
  phelper:OnPluginBroadcast(msg, id, name, text)
  if id == "aaafc15678afa22343c5a327" then
    if msg == 1 then
      -- idle for more than 15 minutes
      -- start going through the cache and updating them (need a coroutine)
    elseif msg == 2 then
      -- no longer idle
      -- stop the coroutine
    end
  end
end

function OnPluginInstall ()
  --OnPluginEnable is automatically called by pluginhelper

  phelper:OnPluginInstall()
end -- OnPluginInstall

function OnPluginClose ()

  phelper:OnPluginClose()
end -- OnPluginClose

function OnPluginEnable ()
  ldplugin ("aard_GMCP_handler", "3e7dedbe37e44942dd46d264")
  ldplugin ("broadcast_idle", "aaabe45678afa22343c5a327")

  if IsConnected() then
    local res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char")
    local char = assert (loadstring ('return ' .. gmcparg or ""))()
    initinv(char)
  end

  dbbackup()
  phelper:OnPluginEnable()
end -- OnPluginEnable

function OnPluginDisable ()

  phelper:OnPluginDisable()
end -- OnPluginDisable

function OnPluginConnect ()
  wearingall = true
  phelper:OnPluginConnect()
end -- function OnPluginConnect

function OnPluginDisconnect ()

  phelper:OnPluginDisconnect()
end -- function OnPluginConnect

function OnPluginSaveState ()

  phelper:OnPluginSaveState()
end -- function OnPluginSaveState

function fixarg(arg)
  if string.find(arg, '[\.]') then
    return arg
  else
    return "'" .. arg .. "'"
  end
end

function OnPluginSend (sText)
  timer_start('eqDB:OnPluginSend')
  local cmd = parse_cmdline(string.lower(sText))
  if not cmd[1] then
    cmd[1] = ""
  end

  local getp = false
  local putp = false
  local removep = false
  local wearp = false
  local lookp = false
  local inp = false
  local alldotp = false

  if lpeg.match(getpeg, string.lower(cmd[1])) ~= nil then
    --print('setting getp')
    getp = true
    if cmd[2] and lpeg.match(alldotpeg, string.lower(cmd[2])) ~= nil then
      print('setting allp')
      alldotp = true
    end
  elseif lpeg.match(putpeg, string.lower(cmd[1])) ~= nil then
    --print('setting putp')
    putp = true
    if cmd[2] and lpeg.match(alldotpeg, string.lower(cmd[2])) ~= nil then
      print('setting allp')
      alldotp = true
    end
  elseif lpeg.match(lookpeg, string.lower(cmd[1])) ~= nil then
    --print('setting lookp')
    lookp = true
  elseif lpeg.match(removepeg, string.lower(cmd[1])) ~= nil then
    --print('setting removep')
    removep = true
  elseif lpeg.match(wearpeg, string.lower(cmd[1])) ~= nil then
    --print('setting wearp')
    wearp = true
  end

  if wearp and cmd[2] == 'all' then
    showoutput('wearingall = true')
    wearingall = true
  elseif removep and cmd[2] == 'all' then
    showoutput('removingall = true')
    removingall = true
  elseif getp and alldotp then
    showoutput('gettingall = true')
    gettingall = true
  elseif putp and alldotp then
    showoutput('puttingall = true')
    puttingall = true
  end

  if getp or putp or wearp or removep
          or lookp then
    --print('looking for identifiers')
    local ncmd = cmd[1]
    local item = cmd[2]
    local cont = cmd[3]
    local nitem = db:getitem(item)
    local citem = nil
    if cont then
      citem = db:getitem(cont)
    end
    if item and nitem then
      ncmd = ncmd .. ' ' .. tostring(nitem.serial)
    elseif item then
      ncmd = ncmd .. ' ' .. fixarg(item)
    end
    if citem then
      ncmd = ncmd .. ' ' .. tostring(citem.serial)
    else
      if not wearp and not removep then
        if nitem then
          if nitem.containerid ~= 'Worn' and nitem.containerid ~= 'Inventory' then
            ncmd = ncmd .. ' ' .. tostring(nitem.containerid)
          end
        end
        if cont then
          ncmd = ncmd .. ' ' .. fixarg(cont)
        end
      end
    end
    if wearp then
      if nitem and nitem.containerid ~= 'Inventory' then
        putobjectininv(nitem)
      end
    end
    showoutput('I would send: ' ..  ncmd)
    SendNoEcho(ncmd)
    timer_end('eqDB:OnPluginSend')
    return false
  end
  timer_end('eqDB:OnPluginSend')
  return true
end
]]>
</script>

<script>
<![CDATA[


phelper:set_default('plugin_colour', 'orange')
phelper:set_default('cmd', 'eqdb')

phelper:add_cmd('refresh', {func=cmd_refresh, help="refresh the db"})
phelper:add_cmd('close', {func=cmd_close, help="close the db"})
phelper:add_cmd('addid', {func=cmd_addid, help="add an identifier to an item"})
phelper:add_cmd('remid', {func=cmd_remid, help="remove an identifier from an item"})
phelper:add_cmd('listid', {func=cmd_listid, help="list items with identifiers"})
phelper:add_cmd('clean', {func=cmd_clean, help="clean the db of stale items"})


phelper:add_setting('showoutput', {help="show tags", type="bool", default=verify_bool(false), after=aftershowset})

phelper:enable()
]]>
</script>
</muclient>
