<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- $Id$ -->
<muclient>
<plugin
   name="xeqDB"
   author="Bast"
   id="aaa56faed92ffc6146964abc"
   language="Lua"
   purpose="add eq to a database"
   save_state="y"
   date_written="2009-02-22 14:20:07"
   requires="4.73"
   version="6.1"
   >

<description trim="y">
<![CDATA[
[FOR PLUGIN AUTHORS ONLY]

#TODO: container changes when getting/removing
#TODO: add designation to containers such as 'special', 'portal', 'potion'

]]>
</description>
</plugin>

<!--  Get our standard constants -->

<include name="constants.lua"/>


<triggers>

 <trigger
   enabled="y"
   match="^Syntax: invdata                - view all inv data.$"
   omit_from_output="n"
   name="badinvdata1"
   sequence="100"
   regexp="y"
  >
  </trigger>

   <trigger
   enabled="y"
   match="^      : invdata <container id> - view all inv data in a container.$"
   omit_from_output="n"
   name="badinvdata2"
   sequence="100"
   regexp="y"
  >
  </trigger>

   <trigger
   enabled="y"
   match="^      : invdata ansi           - remove color codes from output.$"
   omit_from_output="n"
   name="badinvdata3"
   sequence="100"
   regexp="y"
  >
  </trigger>

  <trigger
   enabled="y"
   match="^{invmon}(?&lt;action&gt;.*),(?&lt;serial&gt;.*),(?&lt;container&gt;.*),(?&lt;location&gt;.*)$"
   name="invmon"
   script="invmon"
   sequence="100"
   regexp="y"
   omit_from_output="n"
  >
  </trigger>

 <trigger
   enabled="y"
   match="^{eqdata}$"
   script="eqdata_redirect"
   omit_from_output="n"
   name="start_eqdata"
   sequence="100"
   regexp="y"
  >
  </trigger>

  <trigger
   enabled="n"
   match="*"
   script="eqdata_redirect"
   name="multi_line_eqdata"
   omit_from_output="n"
   group="eqdata"
   sequence="10"
  >
  </trigger>

  <trigger
   enabled="y"
   match="^\{invitem\}(.*)$"
   name="invitem"
   script="invitem"
   sequence="100"
   regexp="y"
   omit_from_output="n"
  >
  </trigger>

 <trigger
   enabled="y"
   match="^{invdata\s*(?&lt;container&gt;.*)}$"
   script="invdata_redirect"
   omit_from_output="n"
   name="start_invdata"
   sequence="100"
   regexp="y"
  >
  </trigger>

  <trigger
   enabled="n"
   match="*"
   script="invdata_redirect"
   name="multi_line_invdata"
   omit_from_output="n"
   group="invdata"
   sequence="10"
  >
  </trigger>
  <trigger
   enabled="n"
   regexp="y"
   match="^$"
   script="emptyline"
   name="emptyline"
   omit_from_output="n"
   group="emptyline"
   sequence="10"
  >
  </trigger>
 <trigger
   enabled="y"
   match="^{invdetails}$"
   script="invdetails_redirect"
   omit_from_output="n"
   name="start_invdetails"
   sequence="100"
   regexp="y"
  >
  </trigger>

  <trigger
   enabled="n"
   match="*"
   script="invdetails_redirect"
   name="multi_line_invdetails"
   omit_from_output="n"
   group="invdetails"
   sequence="10"
  >
  </trigger>
</triggers>

<aliases>

</aliases>


<script>
<![CDATA[
internalrevision = "$Rev$"

dofile (GetPluginInfo (GetPluginID (), 20) .. "luapath.lua")

require "var"
require "serialize"
require "commas"
require "pluginhelper"
require "verify"
require "aardutils"
require "chardb"
require 'colours'
require "eqdb"

db = EQdb:new{}

eqdata = {}
invdata = {}
container = ""
place = 0
initdb = false
wearingall = false
removingall = false
puttingall = false
gettingall = false
silent = true

allcontainer = -1

layout ={
invheader = {"serial", "level", "type", "worth", "weight", "wearable", "flags", "owner", "fromclan", "timer", "u1", "u2", "u3", "score"},
container = {"capacity", "heaviestitem", "holding", "itemsinside", "totalweight", "itemburden", "itemweightpercent"},
statmod = {"stat", "value"},
resistmod = {"resist", "value"},
weapon = {"wtype", "avedam", "inflicts", "damtype", "special"},
skillmod = {"skillnum", "value"},
spells = {"uses", "level", "sn1", "sn2", "sn3", "sn4", "u1"},
food = {"percent"},
drink = {"servings", "liquid", "liquidmax", "liquidleft", "thirstpercent", "hungerpercent", "u1"},
furniture = {"hpregen","manaregen","u1"},
eqdata = {"serial", "shortflags", "name", "level", "type", "unique", "wearslot", "timer"}
}

function sendcmd(cmd)
  if silent then
    SendNoEcho(cmd)
  else
    Send(cmd)
  end
end

function addmod(ltype, mod)
  if invdetails[ltype] == nil then
    invdetails[ltype] = {}
  end
  invdetails[ltype][mod[1]] = tonumber(mod[2])
end

function event_container_change(containerid)
  phelper:processevent('container_change', containerid)
  if containerid ~= 'Worn' and containerid ~= 'Inventory' then
    titem = db:getitemdetails(containerid)
    if titem and next(titem) then
      phelper:processevent('itemchange', titem)
    end
  end
end

function dataparse(line, layoutname)
  local tlist = utils.split(line, ',')
  local wearloc = tlist[7]
  local titem = {}
  for i,v in ipairs(layout[layoutname]) do
    local value = tlist[i]
    if v == 'wearloc' or v == 'itemtype' or v == 'level' then
      value = tonumber(value)
    end
    titem[v] = value
  end
  return titem
end

function eqdata_redirect (name, line, wildcards, styles)
  -- start of spells list? remove old ones
  if name == "start_eqdata" then
    eqdata = {}
    container = 'Worn'
    phelper:enabletriggroup("eqdata", true)
    return
  elseif line == "{/eqdata}" then
    phelper:enabletriggroup("eqdata", false)
    db:clearcontainer(container)
    db:additems(eqdata)
    --db:addcontainer('worn', eqdata)
    event_container_change('Worn')
    return
  end -- if

  if line ~= "" then
    titem = dataparse(line, 'eqdata')
    titem.containerid = container
    titem.place = -2
    titem.plainname = strip_colours(titem.name)
    eqdata[titem.serial] = titem
  end

end

function invdata_redirect (name, line, wildcards, styles)
  -- start of spells list? remove old ones
  if name == "start_invdata" then
    place = 0
    invdata = {}
    if wildcards.container ~= "" then
      container = trim(wildcards.container)
    else
      container = 'Inventory'
    end
    phelper:enabletriggroup("invdata", true)
    return
  elseif line == "{/invdata}" then
    phelper:enabletriggroup("invdata", false)
    db:clearcontainer(container)
    db:additems(invdata)
    --db:addcontainer(container, invdata)
    event_container_change(container)
    if initdb then
      initdb = false
      getcontainers()
    end
    return
  end -- if

  place = place + 1
  titem = dataparse(line, 'eqdata')
  titem.containerid = container
  titem.plainname = strip_colours(titem.name)
  titem.place = place
  invdata[titem.serial] = titem
end

function invdetails_redirect (name, line, wildcards, styles)
  -- start of spells list? remove old ones
  ltype = 'unknown'
  if name == "start_invdetails" then
    invdetails = {}
    timer_start('invdetails')
    phelper:enabletriggroup("invdetails", true)
    return
  elseif line == "{/invdetails}" then
    phelper:enabletriggroup("invdetails", false)
    local titem = db:getitem(invdetails.serial)
    invdetails.name = titem.name
    invdetails.plainname = titem.plainname
    invdetails.containerid = titem.containerid
    invdetails.type = titem.type
    timer_end('invdetails')
    db:additemdetail(invdetails)
    phelper:processevent('itemchange', invdetails)
    return
  end -- if

  ttype = string.match(line,"{(.*)}")
  if layout[ttype] then
    ltype = ttype
  else
    print('no layout for', ttype)
  end

  local tlist = utils.split(line, '}')
  local llist = utils.split(tlist[2], '|')
  if layout[ltype] then
    if ltype == "statmod" or ltype == "resistmod" or ltype == "skillmod" then
      addmod(ltype, llist)
    else
      for i,v in ipairs(layout[ltype]) do
        if ltype == 'invheader' then
          local value = llist[i]
          if v == 'itemtype' or v == 'level' then
            value = tonumber(value)
          end
          invdetails[v] = value
        else
          if invdetails[ltype] == nil then
            invdetails[ltype] = {}
          end
          local value = llist[i]
          if v == 'wearloc' or v == 'itemtype' or v == 'level' then
            value = tonumber(value)
          end
          invdetails[ltype][v] = value
        end
      end
    end
  end
end

function builditem(wildcards)
  local item = {}
  item.placestr = wearlocs[tonumber(wildcards.location) + 1] or -1
  item.wearslot = wildcards.location
  item.serial = wildcards.serial
  item.containerid = wildcards.container
  return item
end

function invmon ( name, line, wildcards )
  phelper:mdebug(line)
  item = builditem(wildcards)
  checkaction(tonumber(wildcards.action), item)
end

function invitem( name, line, wildcards)
  local rline = wildcards[1]
  local tstuff = dataparse(rline, 'eqdata')
  olditem = db:getitem(tstuff.serial)
  if olditem then
    for i,v in pairs(layout['eqdata']) do
      if v ~= 'name' then
        olditem[v] = tstuff[v]
      end
    end
    db:updateitem(olditem)
  end
  event_container_change('Inventory')
end

function emptyline()
  phelper:enabletriggroup("emptyline", false)
  --print('removingall =', removingall)
  --print('wearingall =', wearingall)
  sendcmd('invdata')
  if removingall or wearingall then
    sendcmd('eqdata')
    if phelper.showoutput then
      print('setting removingall and wearingall to false')
    end
    removingall = false
    wearingall = false
  end
  if gettingall or puttingall then
    if allcontainer ~= -1 then
      db:clearcontainer(allcontainer)
      sendcmd('invdata ' .. tostring(allcontainer))
      if phelper.showoutput then
        print('setting gettingall and puttingall = false')
      end
      gettingall = false
      puttingall = false
      allcontainer = -1
    end
  end
end

function initinv(char)
  if char.status and char.status.state and tonumber(char.status.state) == 3 and db:checkfortable('items') == false then
    sendcmd('eqdata')
    sendcmd('invdata')
    initdb = true
  end
end

function getcontainers()
 for i,v in pairs(invdata) do
   if tonumber(v.type) == 11 then
     sendcmd('invdata ' .. tostring(v.serial))
   end
 end
end

function getitemdetails(id)
  --print('getitemdetails', type(id), id)
  local titem = db:getitemdetails(id)
  if titem then
    phelper:processevent('itemchange', titem)
  else
    local titem2 = db:getitem(id)
    if titem2 then
      if titem2.containerid == 'Inventory' or titem2.containerid == 'Worn' then
        sendcmd('invdetails ' .. tostring(id))
      else
        putobjectininv(titem2)
        sendcmd('invdetails ' .. tostring(id))
        putobjectincontainer(titem2, titem2.containerid)
      end
    end
  end
end

function cmd_refresh(cmddict)
  if db:open('cmd_refresh') then
    db:close('cmd_refresh', true)
    db:open('cmd_refresh')
    local returnval = db.db:exec([[DROP TABLE IF EXISTS items;]])
    --print('exec returned: ', returnval)
    db:close('cmd_refresh', true)
    local res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char")
    local char = assert (loadstring ('return ' .. gmcparg or ""))()
    initinv(char)
  end
end

function cmd_close(cmddict)
  db:close('cmd_close', true)
end

function cmd_addid(cmddict)
  if cmddict[1] and cmddict[2] then
    local titem = db:getitem(cmddict[1])
    if titem then
      db:addidentifier(titem.serial, cmddict[2])
    else
      phelper:plugin_header('Add Identifier')
      ColourNote(RGBColourToName(phelper.plugin_colour), "black", "Item " .. cmddict[1] .. " does not exist!")
    end
  end
end

function checkaction(action, item, afterwait)
  if action == 1 and removingall == false then
    timer_start('EQdb:action1')
    -- item removed
    --print('action 1')
    item.containerid = 'Inventory'
    item.wearslot = -1
    item.place = 1
    local reorder = {}
    reorder['Inventory'] = {place=1, containerid='Inventory', removed=false}
    db:reorderitemsmultiple(reorder)
    db:updateitemlocation(item)
    event_container_change('Inventory')
    event_container_change('Worn')
    timer_end('EQdb:action1')
  elseif action == 1 and removingall then
     db:clearcontainer('Worn')
     phelper:enabletriggroup("emptyline", true)
  elseif action == 2 and wearingall == false then
    timer_start('EQdb:action2')
    -- item worn
    --print('action 2')
    item.containerid = 'Worn'
    olditem = db:getitem(item.serial)
    item.place = -2
    local reorder = {}
    if olditem then
      reorder['Inventory'] = {place=olditem.place, containerid='Inventory', removed=true}
      db:reorderitemsmultiple(reorder)
      db:updateitemlocation(item)
      event_container_change('Inventory')
      event_container_change('Worn')
    else
      if phelper.showoutput then
        print('action 2 setting removeall true')
      end
      removingall = true
      phelper:enabletriggroup("emptyline", true)
    end
    timer_end('EQdb:action2')
  elseif action == 2 and wearingall then
   phelper:enabletriggroup("emptyline", true)
  elseif action == 3 then
    -- dropped, sold
    --print('action 3')
    phelper:enabletriggroup("emptyline", true)
  elseif action == 4 then
    -- added (received, picked up)
    --print('action 4')
    phelper:enabletriggroup("emptyline", true)
    --db:additems({item})
  elseif action == 5 and gettingall == false then
    timer_start('EQdb:action5')
    -- removed from container
    --print('action 5')
    olditem = db:getitem(item.serial)
    item.containerid = 'Inventory'
    item.place = 1
    local reorder = {}
    if olditem then
      reorder[olditem.containerid] = {place=olditem.place, containerid=olditem.containerid, removed=true}
    end
    reorder['Inventory'] = {place=1, containerid='Inventory', removed=false}
    db:reorderitemsmultiple(reorder)
    db:updateitemlocation(item)
    event_container_change('Inventory')
    if olditem then
      event_container_change(olditem.containerid)
    end
    timer_end('EQdb:action5')
  elseif action == 5 and gettingall == true then
    db:clearcontainer('Inventory')
    if phelper.showoutput then
      print('action', 5, 'gettingall', gettingall)
    end
    allcontainer = item.containerid
    phelper:enabletriggroup("emptyline", true)
  elseif action == 6 and puttingall == false then
    timer_start('EQdb:action6')
    -- put into container
    --print('action 6')
    olditem = db:getitem(item.serial)
    item.place = 1
    local reorder = {}
    if olditem then
      reorder['Inventory'] = {place=olditem.place, containerid='Inventory', removed=true}
    end
    reorder[item.containerid] = {place=1, containerid=item.containerid, removed=false}
    db:reorderitemsmultiple(reorder)
    db:updateitemlocation(item)
    event_container_change('Inventory')
    event_container_change(item.containerid)
    timer_end('EQdb:action6')
  elseif action == 6 and puttingall == true then
    db:clearcontainer('Inventory')
    if phelper.showoutput then
      print('action', 6, 'puttingall', puttingall)
    end
    allcontainer = item.containerid
    phelper:enabletriggroup("emptyline", true)
  elseif action == 7 then
    -- consumed
    --print('action 7')
    db:removeitems({item})
    event_container_change('Inventory')
  end
end

function toggleoutput(tflag)
  local trigstoupdate = {"invmon", "invitem", "start_invdetails", "multi_line_invdetails", "start_eqdata",
                    "multi_line_eqdata" , "start_invdata", "multi_line_invdata", "badinvdata1",
                    "badinvdata2", "badinvdata3"}
  for i,v in ipairs(trigstoupdate) do
    if tflag then
      SetTriggerOption(v, "omit_from_output", "n");
      silent = false
    else
      SetTriggerOption(v, "omit_from_output", "y");
      silent = true
    end
  end
end

function afterdebug()
  toggleoutput(phelper.tdebug)
end

function aftershowset()
  toggleoutput(phelper.showoutput)
end
]]>
</script>

<script>
<![CDATA[

function OnPluginBroadcast (msg, id, name, text)
  phelper:OnPluginBroadcast(msg, id, name, text)
  if id == "aaafc15678afa22343c5a327" then
    if msg == 1 then
      -- idle for more than 15 minutes
      -- start going through the cache and updating them (need a coroutine)
    elseif msg == 2 then
      -- no longer idle
      -- stop the coroutine
    end
  end
end

function OnPluginInstall ()
  --OnPluginEnable is automatically called by pluginhelper

  phelper:OnPluginInstall()
end -- OnPluginInstall

function OnPluginClose ()

  phelper:OnPluginClose()
end -- OnPluginClose

function OnPluginEnable ()
  ldplugin ("aard_GMCP_handler", "3e7dedbe37e44942dd46d264")
  ldplugin ("broadcast_idle", "aaabe45678afa22343c5a327")

  if IsConnected() then
    local res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char")
    local char = assert (loadstring ('return ' .. gmcparg or ""))()
    initinv(char)
  end

  phelper:OnPluginEnable()
end -- OnPluginEnable

function OnPluginDisable ()

  phelper:OnPluginDisable()
end -- OnPluginDisable

function OnPluginConnect ()
  wearingall = true
  phelper:OnPluginConnect()
end -- function OnPluginConnect

function OnPluginDisconnect ()

  phelper:OnPluginDisconnect()
end -- function OnPluginConnect

function OnPluginSaveState ()

  phelper:OnPluginSaveState()
end -- function OnPluginSaveState

function OnPluginSend (sText)
  if string.match(string.lower(sText), '^[g|ge|get]* .*$') ~= nil or string.match(string.lower(sText), '^[pu|put]* .*$')
          or string.match(string.lower(sText), '^[l|lo|loo|look]* [i|in] .*$') then
    local cmd = parse_cmdline(string.lower(sText))
    local ncmd = cmd[1]
    local item = cmd[2]
    local cont = cmd[3]
    local nitem = db:getitem(item)
    local citem = nil
    if cont then
      citem = db:getitem(cont)
    end
    if nitem then
      ncmd = ncmd .. ' ' .. tostring(nitem.serial)
    else
      ncmd = ncmd .. ' ' .. item
    end
    if citem then
      ncmd = ncmd .. ' ' .. tostring(citem.serial)
    else
      if nitem then
         if nitem.containerid ~= 'Worn' and nitem.containerid ~= 'Inventory' then
           ncmd = ncmd .. ' ' .. tostring(nitem.containerid)
         end
      end
      if cont then
        ncmd = ncmd .. ' ' .. cont
      end
    end
    if phelper.showoutput then
      print('I would send:', ncmd)
    end
    SendNoEcho(ncmd)
    return false
  end
  if string.lower(sText) == 'wea all' or string.lower(sText) == 'wear all' then
    if phelper.showoutput then
      print('wearingall = true')
    end
    wearingall = true
  elseif string.lower(sText) == 're all' or string.lower(sText) == 'rem all' or string.lower(sText) == 'remo all'
          or string.lower(sText) == 'remov all' or string.lower(sText) == 'remove all' then
    if phelper.showoutput then
      print('removingall = true')
    end
    removingall = true
  elseif string.find(string.lower(sText), 'ge all\.') or string.find(string.lower(sText), 'get all\.') or string.find(string.lower(sText), 'g all\.') then
    if phelper.showoutput then
      print('gettingall = true')
    end
    gettingall = true
  elseif string.find(string.lower(sText), 'pu all\.') or string.find(string.lower(sText), 'put all\.') then
    if phelper.showoutput then
      print('puttingall = true')
    end
    puttingall = true
  end  return true
end
]]>
</script>

<script>
<![CDATA[


phelper:set_default('plugin_colour', 'orange')
phelper:set_default('cmd', 'eqdb')

phelper:add_cmd('refresh', {func=cmd_refresh, help="refresh the db"})
phelper:add_cmd('close', {func=cmd_close, help="close the db"})
phelper:add_cmd('addid', {func=cmd_addid, help="add an identifier to an item"})

phelper:add_setting('showoutput', {help="show tags", type="bool", default=verify_bool(false), after=aftershowset})

phelper:enable()
]]>
</script>
</muclient>
